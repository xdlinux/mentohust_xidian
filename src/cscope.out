cscope 15 $HOME/workspace/mentohust/src -q 0000000726 0000077553
	@dlfunc.c

11 
	~"dlfunc.h
"

12 
	~"i18n.h
"

14 #ide
NO_DYLOAD


15 
	~<dlf.h
>

17 (*
pp_fdldevs
)(
pp_if_t
 **, *);

18 (*
pp_䓮ldevs
)(
pp_if_t
 *);

19 
pp_t
 *(*
pp_ݒ_live
)(const *, , , , *);

20 (*
pp_compe
)(
pp_t
 *, 
bpf_ogm
 *, cڡ *, , 
bpf_u_t32
);

21 (*
pp_tfr
)(
pp_t
 *, 
bpf_ogm
 *);

22 *(*
pp_gr
)(
pp_t
 *);

23 (*
pp_code
)(
bpf_ogm
 *);

24 (*
pp_lo
)(
pp_t
 *, , 
pp_hdr
, *);

25 (*
pp_o
)(
pp_t
 *);

26 (*
pp_baklo
)(
pp_t
 *);

27 (*
pp_ndck
)(
pp_t
 *, const *, );

29 *
libpp
 = 
NULL
;

31 
	$ld_libpp
() {

32 *
r
;

33 #ifde
MAC_OS


34 *
fe
[] = {"libpcap.dylib", "libpcap.A.dylib"};

35 
i
, 
cou
 = 2;

37 *
fe
[] = {"libpcap.so", "libpcap.so.1", "libpcap.so.1.0", "libpcap.so.0.9", "libpcap.so.0.8"};

38 
i
, 
cou
 = 5;

40 
i
=0; i<
cou
 && !
libpp
; i++) {

41 
libpp
 = 
	`dlݒ
(
fe
[
i
], 
RTLD_LAZY
);

42 
r
 = 
	`d˼
();

44 i(
libpp
 =
NULL
) {

45 
	`tf
(
	`_
("!! 打开libpcap失败，请检查是否已安装该库文件。\n"));

48 i((
pp_fdldevs
 = 
	`dlsym
(
libpp
, "pp_fdldevs"), 
r
 = 
	`d˼
()!
NULL


49 || (
pp_䓮ldevs
 = 
	`dlsym
(
libpp
, "pp_䓮ldevs"), 
r
 = 
	`d˼
()!
NULL


50 || (
pp_ݒ_live
 = 
	`dlsym
(
libpp
, "pp_ݒ_live"), 
r
 = 
	`d˼
()!
NULL


51 || (
pp_compe
 = 
	`dlsym
(
libpp
, "pp_compe"), 
r
 = 
	`d˼
()!
NULL


52 || (
pp_tfr
 = 
	`dlsym
(
libpp
, "pp_tfr"), 
r
 = 
	`d˼
()!
NULL


53 || (
pp_gr
 = 
	`dlsym
(
libpp
, "pp_gr"), 
r
 = 
	`d˼
()!
NULL


54 || (
pp_code
 = 
	`dlsym
(
libpp
, "pp_code"), 
r
 = 
	`d˼
()!
NULL


55 || (
pp_lo
 = 
	`dlsym
(
libpp
, "pp_lo"), 
r
 = 
	`d˼
()!
NULL


56 || (
pp_o
 = 
	`dlsym
(
libpp
, "pp_o"), 
r
 = 
	`d˼
()!
NULL


57 || (
pp_baklo
 = 
	`dlsym
(
libpp
, "pp_baklo"), 
r
 = 
	`d˼
()!
NULL


58 || (
pp_ndck
 = 
	`dlsym
(
libpp
, "pp_ndck"), 
r
 = 
	`d˼
()!
NULL
) {

59 
	`tf
(
	`_
("!! 从libpp获取函数失败: %s\n"), 
r
);

60 
	`_libpp
();

64 
	}
}

66 
	$_libpp
() {

67 i(
libpp
) {

68 
	`dlo
(
libpp
);

69 
	`d˼
();

70 
libpp
 = 
NULL
;

72 
	}
}

76 #ide
NO_NOTIFY


77 
	~<dlf.h
>

78 
	~<unid.h
>

80 
	tNifyNifiti
, 
	tGtkWidg
, 
	tGE
;

81 
	tgch
;

82 
	tgt
, 
	tgboޗn
;

84 
	$gboޗn
 (*
nify_nifiti_upde
)(
NifyNifiti
 *, cڡ 
gch
 *,

85 cڡ 
gch
 *, const gchar *);

86 (*
nify_nifiti_t_timeout
)(
NifyNifiti
 *, 
gt
);

87 
	$gboޗn
 (*
nify_nifiti_show
)(
NifyNifiti
 *, 
GE
 **);

89 *
libnify
 = 
NULL
;

90 
NifyNifiti
 *
nify
 = 
NULL
;

92 
	$ld_libnify
() {

93 *
r
;

94 
	`gboޗn
 (*
nify_
)(const *);

95 
NifyNifiti
 *(*
nify_nifiti_w
)(cڡ 
gch
 *, const gchar *,

96 cڡ 
gch
 *, 
GtkWidg
 *);

97 #ifde
MAC_OS


98 *
fe
[] = {"libnotify.dylib", "libnotify.1.dylib"};

99 
i
, 
cou
 = 2;

101 *
fe
[] = {"libnotify.so", "libnotify.so.1"};

102 
i
, 
cou
 = 2;

104 
i
=0; i<
cou
 && !
libnify
; i++) {

105 
libnify
 = 
	`dlݒ
(
fe
[
i
], 
RTLD_LAZY
);

106 
r
 = 
	`d˼
();

108 i(
libnify
 =
NULL
) {

109 
	`tf
(
	`_
("!! 打开libnotify失败，请检查是否已安装该库文件。\n"));

112 i((
nify_
 = 
	`dlsym
(
libnify
, "nify_"), 
r
 = 
	`d˼
()!
NULL


113 || (
nify_nifiti_w
 = 
	`dlsym
(
libnify
, "nify_nifiti_w"), 
r
 = 
	`d˼
()!
NULL


114 || (
nify_nifiti_show
 = 
	`dlsym
(
libnify
, "nify_nifiti_show"), 
r
 = 
	`d˼
()!
NULL


115 || (
nify_nifiti_upde
 = 
	`dlsym
(
libnify
, "nify_nifiti_upde"), 
r
 = 
	`d˼
()!
NULL


116 || (
nify_nifiti_t_timeout
 = 
	`dlsym
(
libnify
, "nify_nifiti_t_timeout"), 
r
 = 
	`d˼
()!
NULL
) {

117 
	`tf
(
	`_
("!! 从libnify获取函数失败: %s\n"), 
r
);

118 
	`_libnify
();

121 i(!
	`nify_
("mentohust") ||

122 !(
nify
 = 
	`nify_nifiti_w
("MtoHUST", 
NULL
, NULL, NULL))) {

123 
	`tf
(
	`_
("!! 初始化libnotify失败。\n"));

124 
	`_libnify
();

128 
	}
}

130 
	$_libnify
() {

131 (*
nify_un
)();

132 i(
nify
) {

133 
nify_un
 = 
	`dlsym
(
libnify
, "notify_uninit");

134 i(!
	`d˼
())

135 
	`nify_un
();

136 
nify
 = 
NULL
;

138 i(
libnify
) {

139 
	`dlo
(
libnify
);

140 
	`d˼
();

141 
libnify
 = 
NULL
;

143 
	}
}

145 
	$show_nify
(cڡ *
summy
, *
body
, 
timeout
) {

146 
	`uid
(
	`guid
());

147 i(!
nify
 && 
	`ld_libnify
() < 0) {

148 
	`uid
(0);

151 
	`nify_nifiti_t_timeout
(
nify
, 
timeout
);

152 
	`nify_nifiti_upde
(
nify
, 
summy
, 
body
, 
NULL
);

153 
	`nify_nifiti_show
(
nify
, 
NULL
);

154 
	`uid
(0);

156 
	}
}

	@dlfunc.h

6 #ide
HUSTMOON_DLFUNC_H


7 
	#HUSTMOON_DLFUNC_H


	)

9 #ifde
HAVE_CONFIG_H


10 
	~"cfig.h
"

12 
	~<dio.h
>

13 
	~<sys/time.h
>

15 
	#PCAP_ERRBUF_SIZE
 256

	)

16 
	#PCAP_IF_LOOPBACK
 0x00000001

	)

18 
	tbpf_u_t32
;

19 
	tpp_t
;

20 
	spp_if
 {

21 
pp_if
 *
	mxt
;

22 *
	mme
;

23 *
	mdesti
;

24 *
	maddss
;

25 
bpf_u_t32
 
	mags
;

26 }
	tpp_if_t
;

27 
	sbpf_ogm
 {

28 
	mbf_n
;

29 *
	mbf_s
;

31 
	spp_pkthdr
 {

32 
timev
 
	mts
;

33 
bpf_u_t32
 
	m
;

34 
bpf_u_t32
 
	mn
;

36 (*
	tpp_hdr
)(*, cڡ 
	tpp_pkthdr
 *, const *);

38 #ifde
NO_DYLOAD


39 
	`pp_fdldevs
(
pp_if_t
 **, *);

40 
	`pp_䓮ldevs
(
pp_if_t
 *);

41 
pp_t
 *
	`pp_ݒ_live
(const *, , , , *);

42 
	`pp_compe
(
pp_t
 *, 
bpf_ogm
 *, cڡ *, , 
bpf_u_t32
);

43 
	`pp_tfr
(
pp_t
 *, 
bpf_ogm
 *);

44 *
	`pp_gr
(
pp_t
 *);

45 
	`pp_code
(
bpf_ogm
 *);

46 
	`pp_lo
(
pp_t
 *, , 
pp_hdr
, *);

47 
	`pp_o
(
pp_t
 *);

48 
	`pp_baklo
(
pp_t
 *);

49 
	`pp_ndck
(
pp_t
 *, const *, );

52 (*
pp_fdldevs
)(
pp_if_t
 **, *);

53 (*
pp_䓮ldevs
)(
pp_if_t
 *);

54 
pp_t
 *(*
pp_ݒ_live
)(const *, , , , *);

55 (*
pp_compe
)(
pp_t
 *, 
bpf_ogm
 *, cڡ *, , 
bpf_u_t32
);

56 (*
pp_tfr
)(
pp_t
 *, 
bpf_ogm
 *);

57 *(*
pp_gr
)(
pp_t
 *);

58 (*
pp_code
)(
bpf_ogm
 *);

59 (*
pp_lo
)(
pp_t
 *, , 
pp_hdr
, *);

60 (*
pp_o
)(
pp_t
 *);

61 (*
pp_baklo
)(
pp_t
 *);

62 (*
pp_ndck
)(
pp_t
 *, const *, );

64 
	`ld_libpp
();

65 
	`_libpp
();

69 #ide
NO_NOTIFY


70 
	`_libnify
();

71 
	`show_nify
(cڡ *
summy
, *
body
, 
timeout
);

	@i18n.h

8 #ide
I18N_H_


9 
	#I18N_H_


	)

10 #ifde
HAVE_CONFIG_H


11 
	~"cfig.h
"

13 
	#GETTEXT_PACKAGE
 "mtohu"

	)

16 #ifde
ENABLE_NLS


17 
	~<lib.h
>

18 
	~<lo.h
>

19 
	#_
(
Sg

	`gxt
(Sg)

	)

20 #ifde
gxt_no


21 
	#N_
(
Sg

	`gxt_no
(Sg)

	)

23 
	#N_
(
Sg
(Sg)

	)

26 
	#_
(
Sg
(Sg)

	)

27 
	#N_
(
Sg
(Sg)

	)

	@md5.c

24 
	~"md5.h
"

25 
	~<rg.h
>

28 
	#S11
 7

	)

29 
	#S12
 12

	)

30 
	#S13
 17

	)

31 
	#S14
 22

	)

32 
	#S21
 5

	)

33 
	#S22
 9

	)

34 
	#S23
 14

	)

35 
	#S24
 20

	)

36 
	#S31
 4

	)

37 
	#S32
 11

	)

38 
	#S33
 16

	)

39 
	#S34
 23

	)

40 
	#S41
 6

	)

41 
	#S42
 10

	)

42 
	#S43
 15

	)

43 
	#S44
 21

	)

45 
MD5Tnsfm
(
UINT4
 [4], 
UCHAR
 [64]);

46 
Encode
(
UCHAR
 *, 
UINT4
 *, UINT4);

47 
Decode
(
UINT4
 *, 
UCHAR
 *, UINT4);

49 
UCHAR
 
	gPADDING
[64] = {

57 
	#F
(
x
, 
y
, 
z
(((x& (y)| ((~x& (z)))

	)

58 
	#G
(
x
, 
y
, 
z
(((x& (z)| ((y& (~z)))

	)

59 
	#H
(
x
, 
y
, 
z
((x^ (y^ (z))

	)

60 
	#I
(
x
, 
y
, 
z
((y^ ((x| (~z)))

	)

64 
	#ROTATE_LEFT
(
x
, 
n
(((x<< (n)| ((x>> (32-))))

	)

69 
	#FF
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) { \

70 (
a
+
	`F
 ((
b
), (
c
), (
d
)+ (
x
+ (
UINT4
)(
ac
); \

71 (
a

	`ROTATE_LEFT
 (), (
s
)); \

72 (
a
+(
b
); \

73 }

	)

74 
	#GG
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) { \

75 (
a
+
	`G
 ((
b
), (
c
), (
d
)+ (
x
+ (
UINT4
)(
ac
); \

76 (
a

	`ROTATE_LEFT
 (), (
s
)); \

77 (
a
+(
b
); \

78 }

	)

79 
	#HH
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) { \

80 (
a
+
	`H
 ((
b
), (
c
), (
d
)+ (
x
+ (
UINT4
)(
ac
); \

81 (
a

	`ROTATE_LEFT
 (), (
s
)); \

82 (
a
+(
b
); \

83 }

	)

84 
	#II
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) { \

85 (
a
+
	`I
 ((
b
), (
c
), (
d
)+ (
x
+ (
UINT4
)(
ac
); \

86 (
a

	`ROTATE_LEFT
 (), (
s
)); \

87 (
a
+(
b
); \

88 }

	)

92 
	$MD5In
 (
MD5_CTX
 * 
cڋxt
)

95 
cڋxt
->
cou
[0] = context->count[1] = 0;

98 
cڋxt
->
e
[0] = 0x67452301;

99 
cڋxt
->
e
[1] = 0xefcdab89;

100 
cڋxt
->
e
[2] = 0x98badcfe;

101 
cڋxt
->
e
[3] = 0x10325476;

102 
	}
}

108 
	$MD5Upde
 (
MD5_CTX
 *
cڋxt
, 
UCHAR
 *
put
, 
UINT4
 
putL
)

111 
UINT4
 
i
, 
dex
, 
L
;

114 
dex
 = (
UINT4
)((
cڋxt
->
cou
[0] >> 3) & 0x3F);

117 i((
cڋxt
->
cou
[0] +((
UINT4
)
putL
 << 3))

118 < ((
UINT4
)
putL
 << 3))

119 
cڋxt
->
cou
[1]++;

120 
cڋxt
->
cou
[1] +((
UINT4
)
putL
 >> 29);

122 
L
 = 64 - 
dex
;

126 i(
putL
 >
L
) {

127 
	`memy
((
POINTER
)&
cڋxt
->
bufr
[
dex
], (POINTER)
put
, 
L
);

128 
	`MD5Tnsfm
 (
cڋxt
->
e
, cڋxt->
bufr
);

130 
i
 = 
L
; i + 63 < 
putL
; i += 64)

131 
	`MD5Tnsfm
 (
cڋxt
->
e
, &
put
[
i
]);

133 
dex
 = 0;

136 
i
 = 0;

139 
	`memy
((
POINTER
)&
cڋxt
->
bufr
[
dex
], (POINTER)&
put
[
i
],
putL
-i);

140 
	}
}

145 
	$MD5F
 (
UCHAR
 
dige
[16], 
MD5_CTX
 *
cڋxt
)

147 
UCHAR
 
bs
[8];

148 
UINT4
 
dex
, 
dL
;

151 
	`Encode
 (
bs
, 
cڋxt
->
cou
, 8);

155 
dex
 = (
UINT4
)((
cڋxt
->
cou
[0] >> 3) & 0x3f);

156 
dL
 = (
dex
 < 56) ? (56 - index) : (120 - index);

157 
	`MD5Upde
 (
cڋxt
, 
PADDING
, 
dL
);

160 
	`MD5Upde
 (
cڋxt
, 
bs
, 8);

163 
	`Encode
 (
dige
, 
cڋxt
->
e
, 16);

167 
	`memt
 ((
POINTER
)
cڋxt
, 0,  (*context));

168 
	}
}

172 
	$MD5Tnsfm
 (
UINT4
 
e
[4],
UCHAR
 
block
[64])

174 
UINT4
 
a
 = 
e
[0], 
b
 = s[1], 
c
 = s[2], 
d
 = s[3], 
x
[16];

176 
	`Decode
 (
x
, 
block
, 64);

179 
	`FF
 (
a
, 
b
, 
c
, 
d
, 
x
[ 0], 
S11
, 0xd76aa478);

180 
	`FF
 (
d
, 
a
, 
b
, 
c
, 
x
[ 1], 
S12
, 0xe8c7b756);

181 
	`FF
 (
c
, 
d
, 
a
, 
b
, 
x
[ 2], 
S13
, 0x242070db);

182 
	`FF
 (
b
, 
c
, 
d
, 
a
, 
x
[ 3], 
S14
, 0xc1bdceee);

183 
	`FF
 (
a
, 
b
, 
c
, 
d
, 
x
[ 4], 
S11
, 0xf57c0faf);

184 
	`FF
 (
d
, 
a
, 
b
, 
c
, 
x
[ 5], 
S12
, 0x4787c62a);

185 
	`FF
 (
c
, 
d
, 
a
, 
b
, 
x
[ 6], 
S13
, 0xa8304613);

186 
	`FF
 (
b
, 
c
, 
d
, 
a
, 
x
[ 7], 
S14
, 0xfd469501);

187 
	`FF
 (
a
, 
b
, 
c
, 
d
, 
x
[ 8], 
S11
, 0x698098d8);

188 
	`FF
 (
d
, 
a
, 
b
, 
c
, 
x
[ 9], 
S12
, 0x8b44f7af);

189 
	`FF
 (
c
, 
d
, 
a
, 
b
, 
x
[10], 
S13
, 0xffff5bb1);

190 
	`FF
 (
b
, 
c
, 
d
, 
a
, 
x
[11], 
S14
, 0x895cd7be);

191 
	`FF
 (
a
, 
b
, 
c
, 
d
, 
x
[12], 
S11
, 0x6b901122);

192 
	`FF
 (
d
, 
a
, 
b
, 
c
, 
x
[13], 
S12
, 0xfd987193);

193 
	`FF
 (
c
, 
d
, 
a
, 
b
, 
x
[14], 
S13
, 0xa679438e);

194 
	`FF
 (
b
, 
c
, 
d
, 
a
, 
x
[15], 
S14
, 0x49b40821);

197 
	`GG
 (
a
, 
b
, 
c
, 
d
, 
x
[ 1], 
S21
, 0xf61e2562);

198 
	`GG
 (
d
, 
a
, 
b
, 
c
, 
x
[ 6], 
S22
, 0xc040b340);

199 
	`GG
 (
c
, 
d
, 
a
, 
b
, 
x
[11], 
S23
, 0x265e5a51);

200 
	`GG
 (
b
, 
c
, 
d
, 
a
, 
x
[ 0], 
S24
, 0xe9b6c7aa);

201 
	`GG
 (
a
, 
b
, 
c
, 
d
, 
x
[ 5], 
S21
, 0xd62f105d);

202 
	`GG
 (
d
, 
a
, 
b
, 
c
, 
x
[10], 
S22
, 0x2441453);

203 
	`GG
 (
c
, 
d
, 
a
, 
b
, 
x
[15], 
S23
, 0xd8a1e681);

204 
	`GG
 (
b
, 
c
, 
d
, 
a
, 
x
[ 4], 
S24
, 0xe7d3fbc8);

205 
	`GG
 (
a
, 
b
, 
c
, 
d
, 
x
[ 9], 
S21
, 0x21e1cde6);

206 
	`GG
 (
d
, 
a
, 
b
, 
c
, 
x
[14], 
S22
, 0xc33707d6);

207 
	`GG
 (
c
, 
d
, 
a
, 
b
, 
x
[ 3], 
S23
, 0xf4d50d87);

208 
	`GG
 (
b
, 
c
, 
d
, 
a
, 
x
[ 8], 
S24
, 0x455a14ed);

209 
	`GG
 (
a
, 
b
, 
c
, 
d
, 
x
[13], 
S21
, 0xa9e3e905);

210 
	`GG
 (
d
, 
a
, 
b
, 
c
, 
x
[ 2], 
S22
, 0xfcefa3f8);

211 
	`GG
 (
c
, 
d
, 
a
, 
b
, 
x
[ 7], 
S23
, 0x676f02d9);

212 
	`GG
 (
b
, 
c
, 
d
, 
a
, 
x
[12], 
S24
, 0x8d2a4c8a);

215 
	`HH
 (
a
, 
b
, 
c
, 
d
, 
x
[ 5], 
S31
, 0xfffa3942);

216 
	`HH
 (
d
, 
a
, 
b
, 
c
, 
x
[ 8], 
S32
, 0x8771f681);

217 
	`HH
 (
c
, 
d
, 
a
, 
b
, 
x
[11], 
S33
, 0x6d9d6122);

218 
	`HH
 (
b
, 
c
, 
d
, 
a
, 
x
[14], 
S34
, 0xfde5380c);

219 
	`HH
 (
a
, 
b
, 
c
, 
d
, 
x
[ 1], 
S31
, 0xa4beea44);

220 
	`HH
 (
d
, 
a
, 
b
, 
c
, 
x
[ 4], 
S32
, 0x4bdecfa9);

221 
	`HH
 (
c
, 
d
, 
a
, 
b
, 
x
[ 7], 
S33
, 0xf6bb4b60);

222 
	`HH
 (
b
, 
c
, 
d
, 
a
, 
x
[10], 
S34
, 0xbebfbc70);

223 
	`HH
 (
a
, 
b
, 
c
, 
d
, 
x
[13], 
S31
, 0x289b7ec6);

224 
	`HH
 (
d
, 
a
, 
b
, 
c
, 
x
[ 0], 
S32
, 0xeaa127fa);

225 
	`HH
 (
c
, 
d
, 
a
, 
b
, 
x
[ 3], 
S33
, 0xd4ef3085);

226 
	`HH
 (
b
, 
c
, 
d
, 
a
, 
x
[ 6], 
S34
, 0x4881d05);

227 
	`HH
 (
a
, 
b
, 
c
, 
d
, 
x
[ 9], 
S31
, 0xd9d4d039);

228 
	`HH
 (
d
, 
a
, 
b
, 
c
, 
x
[12], 
S32
, 0xe6db99e5);

229 
	`HH
 (
c
, 
d
, 
a
, 
b
, 
x
[15], 
S33
, 0x1fa27cf8);

230 
	`HH
 (
b
, 
c
, 
d
, 
a
, 
x
[ 2], 
S34
, 0xc4ac5665);

233 
	`II
 (
a
, 
b
, 
c
, 
d
, 
x
[ 0], 
S41
, 0xf4292244);

234 
	`II
 (
d
, 
a
, 
b
, 
c
, 
x
[ 7], 
S42
, 0x432aff97);

235 
	`II
 (
c
, 
d
, 
a
, 
b
, 
x
[14], 
S43
, 0xab9423a7);

236 
	`II
 (
b
, 
c
, 
d
, 
a
, 
x
[ 5], 
S44
, 0xfc93a039);

237 
	`II
 (
a
, 
b
, 
c
, 
d
, 
x
[12], 
S41
, 0x655b59c3);

238 
	`II
 (
d
, 
a
, 
b
, 
c
, 
x
[ 3], 
S42
, 0x8f0ccc92);

239 
	`II
 (
c
, 
d
, 
a
, 
b
, 
x
[10], 
S43
, 0xffeff47d);

240 
	`II
 (
b
, 
c
, 
d
, 
a
, 
x
[ 1], 
S44
, 0x85845dd1);

241 
	`II
 (
a
, 
b
, 
c
, 
d
, 
x
[ 8], 
S41
, 0x6fa87e4f);

242 
	`II
 (
d
, 
a
, 
b
, 
c
, 
x
[15], 
S42
, 0xfe2ce6e0);

243 
	`II
 (
c
, 
d
, 
a
, 
b
, 
x
[ 6], 
S43
, 0xa3014314);

244 
	`II
 (
b
, 
c
, 
d
, 
a
, 
x
[13], 
S44
, 0x4e0811a1);

245 
	`II
 (
a
, 
b
, 
c
, 
d
, 
x
[ 4], 
S41
, 0xf7537e82);

246 
	`II
 (
d
, 
a
, 
b
, 
c
, 
x
[11], 
S42
, 0xbd3af235);

247 
	`II
 (
c
, 
d
, 
a
, 
b
, 
x
[ 2], 
S43
, 0x2ad7d2bb);

248 
	`II
 (
b
, 
c
, 
d
, 
a
, 
x
[ 9], 
S44
, 0xeb86d391);

250 
e
[0] +
a
;

251 
e
[1] +
b
;

252 
e
[2] +
c
;

253 
e
[3] +
d
;

258 
	`memt
 ((
POINTER
)
x
, 0,  (x));

259 
	}
}

264 
	$Encode
 (
UCHAR
 *
ouut
, 
UINT4
 *
put
, UINT4 
n
)

266 
UINT4
 
i
, 
j
;

268 
i
 = 0, 
j
 = 0; j < 
n
; i++, j += 4) {

269 
ouut
[
j
] = (
UCHAR
)(
put
[
i
] & 0xff);

270 
ouut
[
j
+1] = (
UCHAR
)((
put
[
i
] >> 8) & 0xff);

271 
ouut
[
j
+2] = (
UCHAR
)((
put
[
i
] >> 16) & 0xff);

272 
ouut
[
j
+3] = (
UCHAR
)((
put
[
i
] >> 24) & 0xff);

274 
	}
}

279 
	$Decode
 (
UINT4
 *
ouut
, 
UCHAR
 *
put
, UINT4 
n
)

281 
UINT4
 
i
, 
j
;

283 
i
 = 0, 
j
 = 0; j < 
n
; i++, j += 4)

284 
ouut
[
i
] = ((
UINT4
)
put
[
j
]) | (((UINT4)input[j+1]) << 8) |

285 (((
UINT4
)
put
[
j
+2]) << 16) | (((UINT4)input[j+3]) << 24);

286 
	}
}

289 
UCHAR
* 
	$CompuHash
(
UCHAR
* 
c
, 
UINT4
 
n
)

291 
MD5_CTX
 
cڋxt
;

292 
UCHAR
 
dige
[16];

293 
	`MD5In
(&
cڋxt
);

294 
	`MD5Upde
(&
cڋxt
, 
c
, 
n
);

295 
	`MD5F
(
dige
, &
cڋxt
);

296  
dige
;

297 
	}
}

	@md5.h

25 #ide
MD5_H


26 
	#MD5_H


	)

27 
	~"tys.h
"

32 
UINT4
 
	me
[4];

33 
UINT4
 
	mcou
[2];

34 
UCHAR
 
	mbufr
[64];

35 } 
	tMD5_CTX
;

37 
MD5In
(
MD5_CTX
 * 
cڋxt
);

38 
MD5Upde
(
MD5_CTX
 *
cڋxt
, 
UCHAR
 *
put
, 
UINT4
 
putL
);

39 
MD5F
(
UCHAR
 
dige
[16], 
MD5_CTX
 *
cڋxt
);

41 
UCHAR
* 
CompuHash
(UCHAR *
c
, 
UINT4
 
n
);

	@mentohust.c

10 #ifde
HAVE_CONFIG_H


11 
	~"cfig.h
"

14 
	~"mycfig.h
"

15 
	~"i18n.h
"

16 
	~"mye.h
"

17 
	~"myfunc.h
"

18 
	~"dlfunc.h
"

19 
	~<sigl.h
>

20 
	~<rg.h
>

21 
	~<dlib.h
>

22 
	~<t/.h
>

23 
	~<unid.h
>

25 
pp_t
 *
hPp
;

26 vީ
e
;

27 
u_ch
 *
flBuf
;

28 cڡ 
u_ch
 *
pBuf
;

29 
tMode
, 
dhMode
, 
maxFa
;

30 
u_ch
 
deMAC
[];

31 
lockfd
;

32 #ide
NO_NOTIFY


33 
showNify
;

35 #ide
NO_ARP


36 
u_t32_t
 
r
, 
geway
;

37 
u_ch
 
geMAC
[];

40 
ex_hd
();

41 
sig_hd
(
sig
);

42 
pp_hd
(
u_ch
 *
ur
, cڡ 
pp_pkthdr
 *
h
, cڡ u_ch *
buf
);

43 
showRuijMsg
(cڡ 
u_ch
 *
buf
, 
bufL
);

44 
showCtMsg
(cڡ 
u_ch
 *
buf
);

46 
	$ma
(
gc
, **
gv
)

48 #ifde
ENABLE_NLS


49 
	`xtdoma
(
GETTEXT_PACKAGE
);

50 
	`o
(
LC_ALL
, "");

52 
	`ex
(
ex_hd
);

53 
	`Cfig
(
gc
, 
gv
);

54 
	`sigl
(
SIGALRM
, 
sig_hd
);

55 
	`sigl
(
SIGHUP
, 
sig_hd
);

56 
	`sigl
(
SIGINT
, 
sig_hd
);

57 
	`sigl
(
SIGQUIT
, 
sig_hd
);

58 
	`sigl
(
SIGTSTP
, 
sig_hd
);

59 
	`sigl
(
SIGTERM
, 
sig_hd
);

60 i(
dhMode
 == 3)

61 
	`swchS
(
ID_DHCP
);

63 
	`swchS
(
ID_START
);

64 i(-1 =
	`pp_lo
(
hPp
, -1, 
pp_hd
, 
NULL
)) {

65 
	`tf
(
	`_
("!! 捕获数据包失败，请检查网络连接！\n"));

66 #ide
NO_NOTIFY


67 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 错误提示"),

68 
	`_
("捕获数据包失败，请检查网络连接！"), 1000*
showNify
) < 0)

69 
showNify
 = 0;

72 
	`ex
(
EXIT_FAILURE
);

73 
	}
}

75 
	$ex_hd
()

77 i(
e
 !
ID_DISCONNECT
)

78 
	`swchS
(
ID_DISCONNECT
);

79 i(
hPp
 !
NULL
)

80 
	`pp_o
(
hPp
);

81 i(
flBuf
 !
NULL
)

82 
	`
(
flBuf
);

83 i(
lockfd
 > -1)

84 
	`o
(
lockfd
);

85 #ide
NO_NOTIFY


86 
	`_libnify
();

88 #ide
NO_DYLOAD


89 
	`_libpp
();

91 
	`tf
(
	`_
(">> 认证已退出。\n"));

92 
	}
}

94 
	$sig_hd
(
sig
)

96 i(
sig
 =
SIGALRM
)

98 i(-1 =
	`swchS
(
e
))

100 
	`pp_baklo
(
hPp
);

101 
	`tf
(
	`_
("!! 发送数据包失败, 请检查网络连接！\n"));

102 #ide
NO_NOTIFY


103 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 错误提示"),

104 
	`_
("发送数据包失败, 请检查网络连接！"), 1000*
showNify
) < 0)

105 
showNify
 = 0;

107 
	`ex
(
EXIT_FAILURE
);

112 
	`pp_baklo
(
hPp
);

113 
	`ex
(
EXIT_SUCCESS
);

115 
	}
}

117 
	$pp_hd
(
u_ch
 *
ur
, cڡ 
pp_pkthdr
 *
h
, cڡ u_ch *
buf
)

119 
Cou
 = 0;

120 #ide
NO_ARP


121 i(
buf
[0x0c]==0x88 && buf[0x0d]==0x8e) {

123 i(
	`memcmp
(
deMAC
, 
buf
+6, 6)!=0 && 
tMode
>2)

125 
pBuf
 = 
buf
;

126 i(
buf
[0x0F]==0x00 && buf[0x12]==0x01 && buf[0x16]==0x01) {

127 i(
tMode
 < 3) {

128 
	`memy
(
deMAC
, 
buf
+6, 6);

129 
	`tf
(
	`_
("** 认证MAC:\t%s\n"), 
	`fmHex
(
deMAC
, 6));

130 
tMode
 += 3;

132 i(
tMode
==3 && 
	`memcmp
(
buf
+0x17, "Userame", 9)==0)

133 
tMode
 = 5;

134 
	`swchS
(
ID_IDENTITY
);

136 i(
buf
[0x0F]==0x00 && buf[0x12]==0x01 && buf[0x16]==0x04)

137 
	`swchS
(
ID_CHALLENGE
);

138 i(
buf
[0x0F]==0x00 && buf[0x12]==0x03) {

139 
	`tf
(
	`_
(">> 认证成功!\n"));

140 
Cou
 = 0;

141 i(!(
tMode
%3 == 2)) {

142 
	`gEchoKey
(
buf
);

143 
	`showRuijMsg
(
buf
, 
h
->

);

145 i(
dhMode
==1 || dhcpMode==2)

146 
	`swchS
(
ID_DHCP
);

147 i(
tMode
%3 == 2)

148 
	`swchS
(
ID_WAITECHO
);

150 
	`swchS
(
ID_ECHO
);

152 i(
buf
[0x0F]==0x00 && buf[0x12]==0x01 && buf[0x16]==0x02)

153 
	`showCtMsg
(
buf
);

154 i(
buf
[0x0F] == 0x05)

155 
	`swchS
(
ID_ECHO
);

156 i(
buf
[0x0F]==0x00 && buf[0x12]==0x04) {

157 i(
e
==
ID_WAITECHO
 || s==
ID_ECHO
) {

158 
	`tf
(
	`_
(">> 认证掉线，开始重连!\n"));

159 
	`swchS
(
ID_START
);

161 i(
buf
[0x1b]!=0 || 
tMode
%3==2) {

162 
	`tf
(
	`_
(">> 认证失败!\n"));

163 i(
tMode
%3 != 2)

164 
	`showRuijMsg
(
buf
, 
h
->

);

165 i(
maxFa
 && ++
Cou
>=maxFail) {

166 
	`tf
(
	`_
(">> 连续认证失败%u次，退出认证。\n"), 
maxFa
);

167 
	`ex
(
EXIT_SUCCESS
);

169 
	`t
();

172 
	`swchS
(
ID_START
);

174 #ide
NO_ARP


175 } i(
geMAC
[0]!=0xFE && 
buf
[0x0c]==0x08 && buf[0x0d]==0x06) {

176 i(*(
u_t32_t
 *)(
buf
+0x1c=
geway
) {

177 
r
[50];

178 i(
geMAC
[0] == 0xFF) {

179 
	`memy
(
geMAC
, 
buf
+0x16, 6);

180 
	`tf
(
	`_
("** 网关MAC:\t%s\n"), 
	`fmHex
(
geMAC
, 6));

181 
	`rtf
(
r
, "-%%s", 
	`fmIP
(
geway
), 
	`fmHex
(
geMAC
, 6));

182 
	`syem
(
r
);

183 } i(
buf
[0x15]==0x02 && 
	`memcmp
(&
r
, buf+0x26, 4)==0

184 && 
	`memcmp
(
geMAC
, 
buf
+0x16, 6)!=0) {

185 
	`tf
(
	`_
("** ARP欺骗:\t%s\n"), 
	`fmHex
(
buf
+0x16, 6));

186 #ide
NO_NOTIFY


187 i(
showNify
) {

188 
	`rtf
(
r
, 
	`_
("欺骗源: %s"), 
	`fmHex
(
buf
+0x16, 6));

189 i(
	`show_nify
(
	`_
("MtoHUST - ARP提示"), 
r
, 1000*
showNify
) < 0)

190 
showNify
 = 0;

197 
	}
}

199 
	$showRuijMsg
(cڡ 
u_ch
 *
buf
, 
bufL
)

201 *
rvMsg
;

202 
ngth
 = 
buf
[0x1b];

203 i(
ngth
 > 0) {

204 
rvMsg
=(*)(
buf
+0x1c); *rvMsg=='\r'||*rvMsg=='\n'; svMsg++,
ngth
--);

205 i(
	`
(
rvMsg
< 
ngth
)

206 
ngth
 = 
	`
(
rvMsg
);

207 i(
ngth
>0 && (
rvMsg
=
	`gbk2utf
(rvMsg,gth))!=
NULL
) {

208 i(
	`
(
rvMsg
)) {

209 
	`tf
(
	`_
("$$ 系统提示:\t%s\n"), 
rvMsg
);

210 #ide
NO_NOTIFY


211 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 系统提示"),

212 
rvMsg
, 1000*
showNify
) < 0)

213 
showNify
 = 0;

216 
	`
(
rvMsg
);

219 i((
ngth
=0x1c+
buf
[0x1b]+0x69+39< 
bufL
) {

220 
rvMsg
=(*)(
buf
+
ngth
);

221 i(
buf
[
ngth
-1]-2 > 
bufL
-length)

222 
ngth
 = 
bufL
 -ength;

224 
ngth
 = 
buf
[length-1]-2;

225 ; *
rvMsg
=='\r'||*rvMsg=='\n'; svMsg++,
ngth
--);

226 i(
ngth
>0 && (
rvMsg
=
	`gbk2utf
(rvMsg,gth))!=
NULL
) {

227 i(
	`
(
rvMsg
)) {

228 
	`tf
(
	`_
("$$ 计费提示:\t%s\n"), 
rvMsg
);

229 #ide
NO_NOTIFY


230 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 计费提示"),

231 
rvMsg
, 1000*
showNify
) < 0)

232 
showNify
 = 0;

235 
	`
(
rvMsg
);

238 
	}
}

240 
	$showCtMsg
(cڡ 
u_ch
 *
buf
)

242 *
rvMsg
 = (*)(
buf
+0x17);

243 
ngth
 = 
	`ohs
(*(
u_t16_t
 *)(
buf
+0x14)) - 5;

244 i(
	`
(
rvMsg
< 
ngth
)

245 
ngth
 = 
	`
(
rvMsg
);

246 i(
ngth
>0 && (
rvMsg
=
	`gbk2utf
(rvMsg,gth))!=
NULL
)

248 
	`tf
(
	`_
("$$ 系统提示:\t%s\n"), 
rvMsg
);

249 #ide
NO_NOTIFY


250 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 系统提示"),

251 
rvMsg
, 1000*
showNify
) < 0)

252 
showNify
 = 0;

254 
	`
(
rvMsg
);

256 
	}
}

	@mycheck.c

10 #ifde
HAVE_CONFIG_H


11 
	~"cfig.h
"

14 
	~"mycheck.h
"

15 
	~"myi.h
"

16 
	~"md5.h
"

17 
	~<dio.h
>

18 
	~<dlib.h
>

19 
	~<rg.h
>

21 
BYTE
 *
	gb_8021x
 = 
NULL
;

22 
DWORD
 
	gsize_8021x
;

24 #ifde
WORDS_BIGENDIAN


25 
WORD
 
	$obs
(
WORD
 
x
) {

26  ((
x
 & 0xff) << 8) | ((x & 0xff00) >> 8);

27 
	}
}

29 
DWORD
 
	$obl
(
DWORD
 
x
) {

30  ((
x
 & 0xff) << 24) |\

31 ((
x
 & 0xff00) << 8) |\

32 ((
x
 & 0xff0000) >> 8) |\

33 ((
x
 & 0xff000000) >> 24);

34 
	}
}

37 
	$hex_to_r
(cڡ 
BYTE
 *
a
, *
b
, 
hexsize
, 
u
) {

38 cڡ 
BYTE
 
hex
[][17]={"0123456789ABCDEF", "0123456789abcdef"};

39 
BYTE
 *
q
 = (BYTE *)
b
;

40 
i
;

41 
i
=0; i<
hexsize
; i++) {

42 *
q
 = 
hex
[
u
][
a
[
i
]>>4]; q++;

43 *
q
 = 
hex
[
u
][
a
[
i
]&0xf]; q++;

45 *
q
 = 0;

46 
	}
}

48 
BYTE
 *
	$RdCode
(cڡ *
fe
, 
DWORD
 *
size
) {

49 
BYTE
 *
da
 = 
NULL
;

50 
i
;

51 
FILE
 *

;

52 
PPE_HEADER_MAP
 
h
;

54 i((

=
	`fݒ
(
fe
, "rb")=
NULL
)

55 
feE
;

56 
da
 = (
BYTE
 *)
	`mloc
(0x1000);

57 i(
	`d
(
da
, 0x1000, 1, 

) < 1)

58 
feE
;

60 
h
 = (
PPE_HEADER_MAP
)(
da
 + 
	`LTOBL
(((
PIMAGE_DOS_HEADER
)da)->
e_lw
));

61 
i
=0; i<
	`LTOBS
(
h
->
_hd
.
NumbOfSeis
); i++) {

62 i(
	`LTOBL
(
h
->
i_hd
[
i
].
Chaiics
& (
IMAGE_SCN_MEM_EXECUTE
 | 
IMAGE_SCN_CNT_CODE
)) {

63 
	`fek
(

, 
	`LTOBL
(
h
->
i_hd
[
i
].
PorToRawDa
), 
SEEK_SET
);

64 *
size
 = 
	`LTOBL
(
h
->
i_hd
[
i
].
SizeOfRawDa
);

65 
	`
(
da
);

66 
da
 = (
BYTE
 *)
	`mloc
(*
size
);

67 i(
	`d
(
da
, *
size
, 1, 

) < 1)

68 
feE
;

69 
	`fo
(

);

70  
da
;

74 
feE
:

75 i(

 !
NULL
)

76 
	`fo
(

);

77 i(
da
 !
NULL
)

78 
	`
(
da
);

79  
NULL
;

80 
	}
}

82 
BYTE
 *
	$RdCode2
(cڡ *
daFe
, 
DWORD
 *
size
) {

83 
BYTE
 
Buf
[16], *
buf
=Buf;

84 
FILE
 *

 = 
NULL
;

85 i((

=
	`fݒ
(
daFe
, "rb")=
NULL


86 || 
	`d
(
buf
, 16, 1, 

 ) < 1)

87 
feE
;

88 *
size
 = 
	`LTOBL
(*(
UINT4
 *)
buf
 ^ *(UINT4 *)(buf + 4));

89 i(()*
size
 <= 0)

90 
feE
;

91 
buf
 = (
BYTE
 *)
	`mloc
(*
size
+0x100);

92 i(
	`d
(
buf
, *
size
, 1, 

) < 1) {

93 
	`
(
buf
);

94 
feE
;

96 
	`fo
(

);

97  
buf
;

99 
feE
:

100 i(

 !
NULL
)

101 
	`fo
(

);

102  
NULL
;

103 
	}
}

105 
	$decode_d
(
BYTE
 *
c
, BYTE *
d
, 
c_n
, 
d_n
) {

106 
BYTE
 
tmp
[0x8000], *

, *
dp
, *
s_d
 = 
c
+
c_n
+1, *
d_d
 = 
d
+
d_n
, 
s
, 
d
;

107 
DWORD
 
i
, 
m
 = 0, 
n
 = 0;

108 
	`memt
(
tmp
, 0x20, (tmp));

109 
i
=0; i<
c_n
; i++) {

110 
c
[
i
] = 255 - src[i];

112 

=
c
, 
dp
=
d
, 
s
=*++; sp<
s_d
; s=*sp++) {

113 
i
=0; i<8; i++) {

114 
d
 = 1<<
i
;

115 i((
s
&
d
) == 0) {

116 
d
 = *

++;

117 i(

 >
s_d
)

119 
tmp
[(
m
<<7)^
n
] = 
d
;

121 
d
 = 
tmp
[(
m
<<7)^
n
];

123 *
dp
++ = 
d
;

124 i(
dp
 >
d_d
) {

127 
m
 = 
n
;

128 
n
 = 
d
;

131 
	}
}

133 
	$decodeCfig
(cڡ *
fe
, 
BYTE
 *
dbuf
, 
dsize
) {

134 *
sbuf
;

135 
ssize
 = 
	`ldFe
(&
sbuf
, 
fe
);

136 i(
ssize
 < 0)

138 
	`decode_d
((
BYTE
 *)
sbuf
, 
dbuf
, 
ssize
, 
dsize
);

139 
	`
(
sbuf
);

141 
	}
}

143 
	$check_
() {

144 i(
b_8021x
) {

145 
	`
(
b_8021x
);

146 
b_8021x
 = 
NULL
;

148 
	}
}

150 
	$check_
(cڡ *
daFe
) {

151 
me
[0x100];

152 *
p
;

153 
	`check_
();

154 
	`ry
(
me
, 
daFe
);

155 i((
p
=
	`chr
(
me
, '/')+1) == (*)1)

156 
p
 = 
me
;

157 
	`ry
(
p
, "8021x.exe");

158 i((
b_8021x
=
	`RdCode
(
me
, &
size_8021x
)=
NULL


159 && (
b_8021x
=
	`RdCode2
(
daFe
, &
size_8021x
)=
NULL
)

162 
	}
}

164 
	$V2_check
(cڡ 
BYTE
 *
ed
, *
f_r
) {

165 
i
, 
size
 = 
size_8021x
 / 8;

166 
BYTE
 
b
[144], *
md5Dig
, *
b8021x
 = (BYTE *)
	`mloc
(
size
+16);

167 
	`memy
(
b8021x
, 
ed
, 16);

168 
i
=0; i<8; i++) {

169 
	`memy
(
b8021x
+16, 
b_8021x
+
size
*
i
, size);

170 
md5Dig
 = 
	`CompuHash
(
b8021x
, 
size
+16);

171 
b
[18*
i
] = 
ed
[2*i];

172 
	`memy
(
b
+18*
i
+1, 
md5Dig
, 16);

173 
b
[18*
i
+17] = 
ed
[2*i+1];

175 
	`
(
b8021x
);

176 
md5Dig
 = 
	`CompuHash
(
b
, 144);

177 
	`hex_to_r
(
md5Dig
, 
f_r
, 16, 1);

178 
	}
}

180 
DWORD
 
	$gV
(cڡ *
fe
) {

181 
FILE
 *

;

182 
BYTE
 *
da
 = 
NULL
;

183 
i
, 
j
;

184 
DWORD
 
size
, 
VtuAddss
;

185 
PPE_HEADER_MAP
 
h
;

186 
PIMAGE_RESOURCE_DIRECTORY
 
d
;

187 
PIMAGE_RESOURCE_DATA_ENTRY
 
de
;

188 
PVS_VERSIONINFO
 
pvs
;

190 i((

=
	`fݒ
(
fe
, "rb")=
NULL
)

191 
feE
;

192 
da
 = (
BYTE
 *)
	`mloc
(0x1000);

193 i(
	`d
(
da
, 0x1000, 1, 

) < 1)

194 
feE
;

196 
h
 = (
PPE_HEADER_MAP
)(
da
 + 
	`LTOBL
(((
PIMAGE_DOS_HEADER
)da)->
e_lw
));

197 
i
=
	`LTOBS
(
h
->
_hd
.
NumbOfSeis
)-1; i>=0; i--) {

198 i(
	`rcmp
(
h
->
i_hd
[
i
].
Name
, ".rsrc") == 0) {

199 
	`fek
(

, 
	`LTOBL
(
h
->
i_hd
[
i
].
PorToRawDa
), 
SEEK_SET
);

200 
size
 = 
	`LTOBL
(
h
->
i_hd
[
i
].
SizeOfRawDa
);

201 
VtuAddss
 = 
	`LTOBL
(
h
->
i_hd
[
i
].VirtualAddress);

202 
	`
(
da
);

203 
da
 = (
BYTE
 *)
	`mloc
(
size
);

204 i(
	`d
(
da
, 
size
, 1, 

) < 1)

205 
feE
;

206 
d
 = (
PIMAGE_RESOURCE_DIRECTORY
)
da
;

207 
j
=0; j<
	`LTOBS
(
d
->
NumbOfIdErs
); j++) {

208 
d
->
DeyErs
[
j
].
Name
 = 
	`LTOBL
(prd->DirectoryEntries[j].Name);

209 i(
d
->
DeyErs
[
j
].
Id
==16 &&rd->DeyErs[j].
NameIsSg
==0) {

210 
d
->
DeyErs
[
j
].
OfftToDa
 = 
	`LTOBL
(prd->DirectoryEntries[j].OffsetToData);

211 
d
 = (
PIMAGE_RESOURCE_DIRECTORY
)(
da
+d->
DeyErs
[
j
].
OfftToDey
);

212 
d
->
DeyErs
[0].
OfftToDa
 = 
	`LTOBL
(prd->DirectoryEntries[0].OffsetToData);

213 
d
 = (
PIMAGE_RESOURCE_DIRECTORY
)(
da
+d->
DeyErs
[0].
OfftToDey
);

214 
de
 = (
PIMAGE_RESOURCE_DATA_ENTRY
)(
da
+
	`LTOBL
(
d
->
DeyErs
[0].
OfftToDa
));

215 
pvs
 = (
PVS_VERSIONINFO
)(
da
+
	`LTOBL
(
de
->
OfftToDa
)-
VtuAddss
);

216 
size
 = 
pvs
->
Vue
.
dwFeVsiMS
;

217 
	`fo
(

);

218 
	`
(
da
);

219  
size
;

222 
feE
;

226 
feE
:

227 i(

 !
NULL
)

228 
	`fo
(

);

229 i(
da
 !
NULL
)

230 
	`
(
da
);

232 
	}
}

	@mycheck.h

9 #ide
MYCHECK_H


10 
	#MYCHECK_H


	)

12 
	~"tys.h
"

14 
	s_IMAGE_DOS_HEADER
 {

15 
WORD
 
	me_magic
;

16 
WORD
 
	me_cb
;

17 
WORD
 
	me_
;

18 
WORD
 
	me_lc
;

19 
WORD
 
	me_hdr
;

20 
WORD
 
	me_mloc
;

21 
WORD
 
	me_maxloc
;

22 
WORD
 
	me_ss
;

23 
WORD
 
	me_
;

24 
WORD
 
	me_csum
;

25 
WORD
 
	me_
;

26 
WORD
 
	me_cs
;

27 
WORD
 
	me_lc
;

28 
WORD
 
	me_ovno
;

29 
WORD
 
	me_s
[4];

30 
WORD
 
	me_mid
;

31 
WORD
 
	me_mfo
;

32 
WORD
 
	me_s2
[10];

33 
LONG
 
	me_lw
;

34 } 
	tIMAGE_DOS_HEADER
, *
	tPIMAGE_DOS_HEADER
;

36 
	s_IMAGE_FILE_HEADER
 {

37 
WORD
 
	mMache
;

38 
WORD
 
	mNumbOfSeis
;

39 
DWORD
 
	mTimeDeSmp
;

40 
DWORD
 
	mPorToSymbTab
;

41 
DWORD
 
	mNumbOfSymbs
;

42 
WORD
 
	mSizeOfOiڮHd
;

43 
WORD
 
	mChaiics
;

44 } 
	tIMAGE_FILE_HEADER
, *
	tPIMAGE_FILE_HEADER
;

46 
	s_IMAGE_DATA_DIRECTORY
 {

47 
DWORD
 
	mVtuAddss
;

48 
DWORD
 
	mSize
;

49 } 
	tIMAGE_DATA_DIRECTORY
, *
	tPIMAGE_DATA_DIRECTORY
;

51 
	#IMAGE_NUMBEROF_DIRECTORY_ENTRIES
 16

	)

52 
	s_IMAGE_OPTIONAL_HEADER
 {

57 
WORD
 
	mMagic
;

58 
BYTE
 
	mMajLkVsi
;

59 
BYTE
 
	mMLkVsi
;

60 
DWORD
 
	mSizeOfCode
;

61 
DWORD
 
	mSizeOfInlizedDa
;

62 
DWORD
 
	mSizeOfUnlizedDa
;

63 
DWORD
 
	mAddssOfEryPot
;

64 
DWORD
 
	mBaOfCode
;

65 
DWORD
 
	mBaOfDa
;

71 
DWORD
 
	mImageBa
;

72 
DWORD
 
	mSeiAlignmt
;

73 
DWORD
 
	mFeAlignmt
;

74 
WORD
 
	mMajOtgSyemVsi
;

75 
WORD
 
	mMOtgSyemVsi
;

76 
WORD
 
	mMajImageVsi
;

77 
WORD
 
	mMImageVsi
;

78 
WORD
 
	mMajSubsyemVsi
;

79 
WORD
 
	mMSubsyemVsi
;

80 
DWORD
 
	mW32VsiVue
;

81 
DWORD
 
	mSizeOfImage
;

82 
DWORD
 
	mSizeOfHds
;

83 
DWORD
 
	mCheckSum
;

84 
WORD
 
	mSubsyem
;

85 
WORD
 
	mDChaiics
;

86 
DWORD
 
	mSizeOfSckRerve
;

87 
DWORD
 
	mSizeOfSckComm
;

88 
DWORD
 
	mSizeOfHpRerve
;

89 
DWORD
 
	mSizeOfHpComm
;

90 
DWORD
 
	mLdFgs
;

91 
DWORD
 
	mNumbOfRvaAndSizes
;

92 
IMAGE_DATA_DIRECTORY
 
	mDaDey
[
IMAGE_NUMBEROF_DIRECTORY_ENTRIES
];

93 } 
	tIMAGE_OPTIONAL_HEADER
, *
	tPIMAGE_OPTIONAL_HEADER
;

95 
	#IMAGE_SIZEOF_SHORT_NAME
 8

	)

96 
	s_IMAGE_SECTION_HEADER
 {

97 
	mName
[
IMAGE_SIZEOF_SHORT_NAME
];

99 
DWORD
 
	mPhysilAddss
;

100 
DWORD
 
	mVtuSize
;

101 } 
	mMisc
;

102 
DWORD
 
	mVtuAddss
;

103 
DWORD
 
	mSizeOfRawDa
;

104 
DWORD
 
	mPorToRawDa
;

105 
DWORD
 
	mPorToRotis
;

106 
DWORD
 
	mPorToLumbs
;

107 
WORD
 
	mNumbOfRotis
;

108 
WORD
 
	mNumbOfLumbs
;

109 
DWORD
 
	mChaiics
;

110 } 
	tIMAGE_SECTION_HEADER
, *
	tPIMAGE_SECTION_HEADER
;

112 
	s_PE_HEADER_MAP


114 
DWORD
 
	msigtu
;

115 
IMAGE_FILE_HEADER
 
	m_hd
;

116 
IMAGE_OPTIONAL_HEADER
 
	mt_hd
;

117 
IMAGE_SECTION_HEADER
 
	mi_hd
[8];

118 }
	tPE_HEADER_MAP
,*
	tPPE_HEADER_MAP
;

120 
	s_IMAGE_RESOURCE_DIRECTORY_ENTRY
 {

121 #ifde
WORDS_BIGENDIAN


124 
DWORD
 
	mNameIsSg
:1;

125 
DWORD
 
	mNameOfft
:31;

127 
DWORD
 
	mName
;

129 
WORD
 
	mId_unu
;

130 
WORD
 
	mId
;

134 
DWORD
 
	mOfftToDa
;

136 
DWORD
 
	mDaIsDey
:1;

137 
DWORD
 
	mOfftToDey
:31;

143 
DWORD
 
	mNameOfft
:31;

144 
DWORD
 
	mNameIsSg
:1;

146 
DWORD
 
	mName
;

147 
WORD
 
	mId
;

150 
DWORD
 
	mOfftToDa
;

152 
DWORD
 
	mOfftToDey
:31;

153 
DWORD
 
	mDaIsDey
:1;

157 } 
	tIMAGE_RESOURCE_DIRECTORY_ENTRY
, *
	tPIMAGE_RESOURCE_DIRECTORY_ENTRY
;

159 
	s_IMAGE_RESOURCE_DIRECTORY
 {

160 
DWORD
 
	mChaiics
;

161 
DWORD
 
	mTimeDeSmp
;

162 
WORD
 
	mMajVsi
;

163 
WORD
 
	mMVsi
;

164 
WORD
 
	mNumbOfNamedErs
;

165 
WORD
 
	mNumbOfIdErs
;

166 
IMAGE_RESOURCE_DIRECTORY_ENTRY
 
	mDeyErs
[];

167 } 
	tIMAGE_RESOURCE_DIRECTORY
, *
	tPIMAGE_RESOURCE_DIRECTORY
;

169 
	s_IMAGE_RESOURCE_DATA_ENTRY
 {

170 
DWORD
 
	mOfftToDa
;

171 
DWORD
 
	mSize
;

172 
DWORD
 
	mCodePage
;

173 
DWORD
 
	mRerved
;

174 } 
	tIMAGE_RESOURCE_DATA_ENTRY
, *
	tPIMAGE_RESOURCE_DATA_ENTRY
;

176 
	sgVS_FIXEDFILEINFO
 {

177 
DWORD
 
	mdwSigtu
;

178 
DWORD
 
	mdwSucVsi
;

179 
DWORD
 
	mdwFeVsiMS
;

180 
DWORD
 
	mdwFeVsiLS
;

181 
DWORD
 
	mdwProduVsiMS
;

182 
DWORD
 
	mdwProduVsiLS
;

183 
DWORD
 
	mdwFeFgsMask
;

184 
DWORD
 
	mdwFeFgs
;

185 
DWORD
 
	mdwFeOS
;

186 
DWORD
 
	mdwFeTy
;

187 
DWORD
 
	mdwFeSubty
;

188 
DWORD
 
	mdwFeDeMS
;

189 
DWORD
 
	mdwFeDeLS
;

190 } 
	tVS_FIXEDFILEINFO
;

192 
	s_VS_VERSIONINFO
 {

193 
WORD
 
	mwLgth
;

194 
WORD
 
	mwVueLgth
;

195 
WORD
 
	mwTy
;

196 
WORD
 
	mszKey
[16];

197 
WORD
 
	mPaddg1
[1];

198 
VS_FIXEDFILEINFO
 
	mVue
;

199 } 
	tVS_VERSIONINFO
, *
	tPVS_VERSIONINFO
;

201 
	#IMAGE_SCN_CNT_CODE
 0x00000020

202 
	#IMAGE_SCN_MEM_EXECUTE
 0x20000000

203 

	)

204 #ifde
WORDS_BIGENDIAN


205 
	#LTOBS
(
x

	`obs
(x)

	)

206 
	#LTOBL
(
x

	`obl
(x)

	)

207 
WORD
 
obs
(WORD 
x
);

208 
DWORD
 
obl
(DWORD 
x
);

210 
	#LTOBS
(
x
(x)

	)

211 
	#LTOBL
(
x
(x)

	)

214 
decodeCfig
(cڡ *
fe
, 
BYTE
 *
dbuf
, 
dsize
);

215 
check_
(cڡ *
daFe
);

216 
V2_check
(cڡ 
BYTE
 *
ed
, *
f_r
);

217 
check_
();

218 
DWORD
 
gV
(cڡ *
fe
);

	@myconfig.c

11 #ifde
HAVE_CONFIG_H


12 
	~"cfig.h
"

14 cڡ *
	gVERSION
 = "0.3.1 西电修改版";

15 cڡ *
	gPACKAGE_BUGREPORT
 = "http://code.google.com/p/mentohust/issues/list";

18 
	~"mycfig.h
"

19 
	~"i18n.h
"

20 
	~"myi.h
"

21 
	~"myfunc.h
"

22 
	~"dlfunc.h
"

23 
	~<rg.h
>

24 
	~</.h
>

25 
	~<f.h
>

26 
	~<sigl.h
>

27 
	~<unid.h
>

28 
	~<sys/.h
>

30 
	#ACCOUNT_SIZE
 65

	)

31 
	#NIC_SIZE
 16

	)

32 
	#MAX_PATH
 255

	)

33 
	#D_TIMEOUT
 8

	)

34 
	#D_ECHOINTERVAL
 30

	)

35 
	#D_RESTARTWAIT
 15

	)

36 
	#D_STARTMODE
 0

	)

37 
	#D_DHCPMODE
 3

	)

38 
	#D_DAEMONMODE
 0

	)

39 
	#D_MAXFAIL
 8

	)

41 #ifde
MAC_OS


42 cڡ *
	gD_DHCPSCRIPT
 = "dhcping -v -t 15";

44 cڡ *
	gD_DHCPSCRIPT
 = "dhclient";

46 cڡ *
	gCFG_FILE
 = "/etc/mentohust.conf";

47 cڡ *
	gLOG_FILE
 = "/tmp/mentohust.log";

48 cڡ *
	gLOCK_FILE
 = "/var/run/mentohust.pid";

49 
	#LOCKMODE
 (
S_IRUSR
 | 
S_IWUSR
 | 
S_IRGRP
 | 
S_IROTH


	)

51 #ide
NO_NOTIFY


52 
	#D_SHOWNOTIFY
 5

	)

53 
	gshowNify
 = 
D_SHOWNOTIFY
;

56 
bufTy
;

57 
u_ch
 
vsi
[];

58 
	gurName
[
ACCOUNT_SIZE
] = "";

59 
	gsswd
[
ACCOUNT_SIZE
] = "";

60 
	gnic
[
NIC_SIZE
] = "";

61 
	gdaFe
[
MAX_PATH
] = "";

62 
	gdhSt
[
MAX_PATH
] = "";

63 
u_t32_t
 
	g
 = 0;

64 
u_t32_t
 
	gmask
 = 0;

65 
u_t32_t
 
	ggeway
 = 0;

66 
u_t32_t
 
	gdns
 = 0;

67 
u_t32_t
 
	gpgHo
 = 0;

68 
u_ch
 
	glolMAC
[6];

69 
u_ch
 
	gdeMAC
[6];

70 
	gtimeout
 = 
D_TIMEOUT
;

71 
	gechoIv
 = 
D_ECHOINTERVAL
;

72 
	gtWa
 = 
D_RESTARTWAIT
;

73 
	gtMode
 = 
D_STARTMODE
;

74 
	gdhMode
 = 
D_DHCPMODE
;

75 
	gmaxFa
 = 
D_MAXFAIL
;

76 
pp_t
 *
	ghPp
 = 
NULL
;

77 
	glockfd
 = -1;

79 
adFe
(*
dmMode
);

80 
adArg
(
gc
, **
gv
, *
veFg
, *
exFg
, *
dmMode
);

81 
showHp
(cڡ *
feName
);

82 
gAdr
();

83 
tCfig
();

84 
ݒPp
();

85 
veCfig
(
dmMode
);

86 
checkRug
(
exFg
, 
dmMode
);

88 #ide
NO_ENCODE_PASS


89 cڡ 
	gba64Tab
[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"};

90 cڡ 
	gxRuij
[] = {"~!:?$*<(qw2e5o7i8x12c6m67s98w43d2l45we82q3iuu1z4xle23rt4oxclle34e54u6r8m"};

92 
	$codePass
(*
d
, cڡ *
oc
) {

93 

[3], 
buf
[70];

94 *
c
 = 
buf
;

95 
sz
 = 
	`
(
oc
);

96 
i
, 
n
;

97 i((
xRuij
< 
sz
)

99 
i
=0; i<
sz
; i++)

100 
c
[
i
] = 
oc
[i] ^ 
xRuij
[i];

101 
sz
 > 0) {

102 
n
=0, 
i
=0; i<3; i++, 
sz
--) {

103 i(
sz
 > 0) {

104 
n
++;

105 

[
i
] = 
c
[i];

106 } 

[
i
] = 0;

108 
c
 += 3;

109 i(
n
) {

110 
d
[0] = 
ba64Tab
[ 

[0] >> 2 ];

111 
d
[1] = 
ba64Tab
[ ((

[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];

112 
d
[2] = 
n
 > 1 ? 
ba64Tab
[ ((

[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=';

113 
d
[3] = 
n
 > 2 ? 
ba64Tab
[ 

[2] & 0x3f ] : '=';

114 
d
 += 4;

117 *
d
 = '\0';

119 
	}
}

121 
	$decodePass
(*
d
, cڡ *
c
) {

122 
esi
 = 0, 
idx
 = 0;

123 
i
=0, 
j
=0, 
equ
=0;

124 ; 
c
[
i
]!='\0'; i++) {

125 i(
c
[
i
] == '=') {

126 i(++
equ
 > 2)

129 
idx
=0; 
ba64Tab
[idx]!='\0'; idx++) {

130 if(
ba64Tab
[
idx
] =
c
[
i
])

133 i(
idx
 == 64)

135 
esi
 +
idx
;

137 if(
i
%4 == 3) {

138 
d
[
j
++] = ()(
esi
>>16);

139 if(
equ
 < 2)

140 
d
[
j
++] = ()(
esi
>>8);

141 if(
equ
 < 1)

142 
d
[
j
++] = ()
esi
;

143 
esi
 = 0;

144 
equ
 = 0;

146 
esi
 <<= 6;

148 i(
i
%4!=0 || (
xRuij
)<
j
)

150 
i
=0; i<
j
; i++)

151 
d
[
i
] ^
xRuij
[i];

152 
d
[
j
] = '\0';

154 
	}
}

157 
	$Cfig
(
gc
, **
gv
)

159 
veFg
 = 0;

160 
exFg
 = 0;

161 
dmMode
 = 
D_DAEMONMODE
;

162 
	`tf
(
	`_
("\n欢迎使用MentoHUST\t版本: 0.3.1 西电修改版\n"

165 "Bug܈t%s\n\n"), 
PACKAGE_BUGREPORT
);

166 
veFg
 = (
	`adFe
(&
dmMode
)==0 ? 0 : 1);

167 
	`adArg
(
gc
, 
gv
, &
veFg
, &
exFg
, &
dmMode
);

168 #ide
NO_DYLOAD


169 i(
	`ld_libpp
() == -1) {

170 #ide
NO_NOTIFY


171 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 错误提示"),

172 
	`_
("载入libpp失败, 请检查该库文件！"), 1000*
showNify
) < 0)

173 
showNify
 = 0;

175 
	`ex
(
EXIT_FAILURE
);

178 i(
nic
[0] == '\0')

180 
veFg
 = 1;

181 i(
	`gAdr
() == -1) {

182 #ide
NO_NOTIFY


183 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 错误提示"),

184 
	`_
("找不到网卡！"), 1000*
showNify
) < 0)

185 
showNify
 = 0;

187 
	`ex
(
EXIT_FAILURE
);

190 i(
urName
[0]=='\0' || 
sswd
[0]=='\0')

192 
veFg
 = 1;

193 
	`tf
(
	`_
("?? 请输入用户名: "));

194 
	`snf
("%s", 
urName
);

195 
	`tf
(
	`_
("?? 请输入密码: "));

196 
	`snf
("%s", 
sswd
);

197 
	`tf
(
	`_
("?? 请选择组播地址(0标准 1锐捷私有 2赛尔): "));

198 
	`snf
("%u", &
tMode
);

199 
tMode
 %= 3;

200 
dhMode
 =3;

201 
dhMode
 %= 4;

203 
	`checkRug
(
exFg
, 
dmMode
);

204 i(
tMode
%3==2 && 
geway
==0)

206 
geway
 = 

;

207 ((
u_ch
 *)&
geway
)[3] = 0x02;

209 i(
dhSt
[0] == '\0')

210 
	`ry
(
dhSt
, 
D_DHCPSCRIPT
);

211 
	`wBufr
();

212 
	`tCfig
();

213 i(
	`flHd
()==-1 || 
	`ݒPp
()==-1) {

214 #ide
NO_NOTIFY


215 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 错误提示"),

216 
	`_
("获取MAC地址或打开网卡失败！"), 1000*
showNify
) < 0)

217 
showNify
 = 0;

219 
	`ex
(
EXIT_FAILURE
);

221 i(
veFg
)

222 
	`veCfig
(
dmMode
);

223 
	}
}

225 
	$adFe
(*
dmMode
)

227 
tmp
[16], *
buf
;

228 i(
	`ldFe
(&
buf
, 
CFG_FILE
) < 0)

230 
	`gSg
(
buf
, "MtoHUST", "Uame", "", 
urName
, (userName));

231 #ifde
NO_ENCODE_PASS


232 
	`gSg
(
buf
, "MtoHUST", "Passwd", "", 
sswd
, (password));

234 
ss
[
ACCOUNT_SIZE
*4/3+1];

235 
	`gSg
(
buf
, "MtoHUST", "Passwd", "", 
ss
, (pass));

236 i(
ss
[0] == ' ') {

237 
	`decodePass
(
sswd
, 
ss
+1);

239 
	`y
(
sswd
, 
ss
, (password)-1);

240 
	`codePass
(
ss
+1, 
sswd
);

241 
ss
[0] = ' ';

242 
	`tSg
(&
buf
, "MtoHUST", "Passwd", 
ss
);

243 
	`veFe
(
buf
, 
CFG_FILE
);

246 
	`gSg
(
buf
, "MtoHUST", "Nic", "", 
nic
, (nic));

247 
	`gSg
(
buf
, "MtoHUST", "Dafe", "", 
daFe
, (dataFile));

248 
	`gSg
(
buf
, "MtoHUST", "DhSt", "", 
dhSt
, (dhcpScript));

249 
	`gSg
(
buf
, "MtoHUST", "Vsi", "", 
tmp
, (tmp));

250 i(
	`
(
tmp
) >= 3) {

251 
v
[2];

252 i(
	`ssnf
(
tmp
, "%u.%u", 
v
, v+1)!=
EOF
 && ver[0]!=0) {

253 
vsi
[0] = 
v
[0];

254 
vsi
[1] = 
v
[1];

255 
bufTy
 = 1;

258 
	`gSg
(
buf
, "MtoHUST", "IP", "255.255.255.255", 
tmp
, (tmp));

259 

 = 
	`_addr
(
tmp
);

260 
	`gSg
(
buf
, "MtoHUST", "Mask", "255.255.255.255", 
tmp
, (tmp));

261 
mask
 = 
	`_addr
(
tmp
);

262 
	`gSg
(
buf
, "MtoHUST", "Geway", "0.0.0.0", 
tmp
, (tmp));

263 
geway
 = 
	`_addr
(
tmp
);

264 
	`gSg
(
buf
, "MtoHUST", "DNS", "0.0.0.0", 
tmp
, (tmp));

265 
dns
 = 
	`_addr
(
tmp
);

266 
	`gSg
(
buf
, "MtoHUST", "PgHo", "0.0.0.0", 
tmp
, (tmp));

267 
pgHo
 = 
	`_addr
(
tmp
);

268 
timeout
 = 
	`gI
(
buf
, "MtoHUST", "Timeout", 
D_TIMEOUT
) % 100;

269 
echoIv
 = 
	`gI
(
buf
, "MtoHUST", "EchoIv", 
D_ECHOINTERVAL
) % 1000;

270 
tWa
 = 
	`gI
(
buf
, "MtoHUST", "RetWa", 
D_RESTARTWAIT
) % 100;

271 
tMode
 = 
	`gI
(
buf
, "MtoHUST", "SMode", 
D_STARTMODE
) % 3;

272 
dhMode
 = 
	`gI
(
buf
, "MtoHUST", "DhMode", 
D_DHCPMODE
) % 4;

273 #ide
NO_NOTIFY


274 
showNify
 = 
	`gI
(
buf
, "MtoHUST", "ShowNify", 
D_SHOWNOTIFY
) % 21;

276 *
dmMode
 = 
	`gI
(
buf
, "MtoHUST", "DmMode", 
D_DAEMONMODE
) % 4;

277 
maxFa
 = 
	`gI
(
buf
, "MtoHUST", "MaxFa", 
D_MAXFAIL
);

278 
	`
(
buf
);

280 
	}
}

282 
	$adArg
(
gc
, **
gv
, *
veFg
, *
exFg
, *
dmMode
)

284 *
r
, 
c
;

285 
i
;

286 
i
=1; i<
gc
; i++)

288 
r
 = 
gv
[
i
];

289 i(
r
[0]!='-' && str[0]!='/')

291 
c
 = 
r
[1];

292 i(
c
=='h' || c=='?' || 
	`rcmp
(
r
, "--help")==0)

293 
	`showHp
(
gv
[0]);

294 i(
c
 == 'q') {

295 
	`tSuCfig
(
r
+2);

296 
	`ex
(
EXIT_SUCCESS
);

298 i(
c
 == 'w')

299 *
veFg
 = 1;

300 i(
c
 == 'k') {

301 i(
	`
(
r
) > 2)

302 *
exFg
 = 2;

304 *
exFg
 = 1;

307 } i(
	`
(
r
) > 2) {

308 i(
c
 == 'u')

309 
	`y
(
urName
, 
r
+2, (userName)-1);

310 i(
c
 == 'p')

311 
	`y
(
sswd
, 
r
+2, (password)-1);

312 i(
c
 == 'n')

313 
	`y
(
nic
, 
r
+2, (nic)-1);

314 i(
c
 == 'f')

315 
	`y
(
daFe
, 
r
+2, (dataFile)-1);

316 i(
c
 == 'c')

317 
	`y
(
dhSt
, 
r
+2, (dhcpScript)-1);

318 i(
c
=='v' && 
	`
(
r
+2)>=3) {

319 
v
[2];

320 i(
	`ssnf
(
r
+2, "%u.%u", 
v
, v+1!
EOF
) {

321 i(
v
[0] == 0)

322 
bufTy
 = 0;

324 
vsi
[0] = 
v
[0];

325 
vsi
[1] = 
v
[1];

326 
bufTy
 = 1;

330 i(
c
 == 'i')

331 

 = 
	`_addr
(
r
+2);

332 i(
c
 == 'm')

333 
mask
 = 
	`_addr
(
r
+2);

334 i(
c
 == 'g')

335 
geway
 = 
	`_addr
(
r
+2);

336 i(
c
 == 's')

337 
dns
 = 
	`_addr
(
r
+2);

338 i(
c
 == 'o')

339 
pgHo
 = 
	`_addr
(
r
+2);

340 i(
c
 == 't')

341 
timeout
 = 
	`oi
(
r
+2) % 100;

342 i(
c
 == 'e')

343 
echoIv
 = 
	`oi
(
r
+2) % 1000;

344 i(
c
 == 'r')

345 
tWa
 = 
	`oi
(
r
+2) % 100;

346 i(
c
 == 'a')

347 
tMode
 = 
	`oi
(
r
+2) % 3;

348 i(
c
 == 'd')

349 
dhMode
 = 
	`oi
(
r
+2) % 4;

350 #ide
NO_NOTIFY


351 i(
c
 == 'y')

352 
showNify
 = 
	`oi
(
r
+2) % 21;

354 i(
c
 == 'b')

355 *
dmMode
 = 
	`oi
(
r
+2) % 4;

356 i(
c
 == 'l')

357 
maxFa
 = 
	`oi
(
r
+2);

360 
	}
}

362 
	$showHp
(cڡ *
feName
)

364 *
hpSg
 =

365 
	`_
("用法:\t%s [-选项][参数]\n"

384 #ide
NO_NOTIFY


393 
	`tf
(
hpSg
, 
feName
, fileName);

394 
	`ex
(
EXIT_SUCCESS
);

395 
	}
}

397 
	$gAdr
()

399 
pp_if_t
 *
ldevs
, *
d
;

400 
num
 = 0, 
ava
 = 0, 
i
;

401 
rbuf
[
PCAP_ERRBUF_SIZE
];

402 i(
	`pp_fdldevs
(&
ldevs
, 
rbuf
)==-1 ||devs==
NULL
)

404 
	`tf
(
	`_
("!! 查找网卡失败: %s\n"), 
rbuf
);

407 
d
=
ldevs
; d!=
NULL
; d=d->
xt
)

409 
num
++;

410 i(!(
d
->
ags
 & 
PCAP_IF_LOOPBACK
&& 
	`rcmp
(d->
me
, "any")!=0)

412 
	`tf
(
	`_
("** 网卡[%d]:\t%s\n"), 
num
, 
d
->
me
);

413 
ava
++;

414 
i
 = 
num
;

417 i(
ava
 == 0)

419 
	`pp_䓮ldevs
(
ldevs
);

420 
	`tf
(
	`_
("!! 找不到网卡！\n"));

423 i(
ava
 > 1)

425 
	`tf
(
	`_
("?? 请选择网卡[1-%d]: "), 
num
);

426 
	`snf
("%d", &
i
);

427 i(
i
 < 1)

428 
i
 = 1;

429 i(
i
 > 
num
)

430 
i
 = 
num
;

432 
	`tf
(
	`_
("** 您选择了第[%d]块网卡。\n"), 
i
);

433 
d
=
ldevs
; 
i
>1; d=d->
xt
, i--);

434 
	`y
(
nic
, 
d
->
me
, (nic)-1);

435 
	`pp_䓮ldevs
(
ldevs
);

437 
	}
}

439 
	$tCfig
()

441 *
addr
[] = {
	`_
("标准"), _("锐捷"), _("赛尔")};

442 *
dh
[] = {
	`_
("不使用"), _("二次认证"), _("认证后"), _("认证前")};

443 
	`tf
(
	`_
("** 用户名:\t%s\n"), 
urName
);

445 
	`tf
(
	`_
("** 网卡: \t%s\n"), 
nic
);

446 i(
geway
)

447 
	`tf
(
	`_
("** 网关地址:\t%s\n"), 
	`fmIP
(
geway
));

448 i(
dns
)

449 
	`tf
(
	`_
("** DNS地址:\t%s\n"), 
	`fmIP
(
dns
));

450 i(
pgHo
)

451 
	`tf
(
	`_
("** 智能重连:\t%s\n"), 
	`fmIP
(
pgHo
));

452 
	`tf
(
	`_
("** 认证超时:\t%u秒\n"), 
timeout
);

453 
	`tf
(
	`_
("** 心跳间隔:\t%u秒\n"), 
echoIv
);

454 
	`tf
(
	`_
("** 失败等待:\t%u秒\n"), 
tWa
);

455 i(
maxFa
)

456 
	`tf
(
	`_
("** 允许失败:\t%u次\n"), 
maxFa
);

457 
	`tf
(
	`_
("** 组播地址:\t%s\n"), 
addr
[
tMode
]);

458 
	`tf
(
	`_
("** DHCP方式:\t%s\n"), 
dh
[
dhMode
]);

459 #ide
NO_NOTIFY


460 i(
showNify
)

461 
	`tf
(
	`_
("** 通知超时:\t%d秒\n"), 
showNify
);

463 i(
bufTy
 >= 2)

464 
	`tf
(
	`_
("** 数据文件:\t%s\n"), 
daFe
);

465 i(
dhMode
 != 0)

466 
	`tf
(
	`_
("** DHCP脚本:\t%s\n"), 
dhSt
);

467 
	}
}

469 
	$ݒPp
()

471 
buf
[
PCAP_ERRBUF_SIZE
], *
fmt
;

472 
bpf_ogm
 
fcode
;

473 i((
hPp
 = 
	`pp_ݒ_live
(
nic
, 2048, 1, 1000, 
buf
)=
NULL
)

475 
	`tf
(
	`_
("!! 打开网卡%s失败: %s\n"), 
nic
, 
buf
);

478 
fmt
 = 
	`fmHex
(
lolMAC
, 6);

479 #ide
NO_ARP


480 
	`rtf
(
buf
, "((etherroto 0x888end (ether dst %s orther dst 01:80:c2:00:00:03)) "

481 "܃thr0x0806dكth sr%s", 
fmt
, fmt);

483 
	`rtf
(
buf
, "etherroto 0x888end (ether dst %s orther dst 01:80:c2:00:00:03) "

484 "dكth sr%s", 
fmt
, fmt);

486 i(
	`pp_compe
(
hPp
, &
fcode
, 
buf
, 0, 0xffffffff) == -1

487 || 
	`pp_tfr
(
hPp
, &
fcode
) == -1)

489 
	`tf
(
	`_
("!! 设置pp过滤器失败: %s\n"), 
	`pp_gr
(
hPp
));

492 
	`pp_code
(&
fcode
);

494 
	}
}

496 
	$veCfig
(
dmMode
)

498 *
buf
;

499 i(
	`ldFe
(&
buf
, 
CFG_FILE
) < 0) {

500 
buf
 = (*)
	`mloc
(1);

501 
buf
[0] = '\0';

503 
	`tSg
(&
buf
, "MtoHUST", "DhSt", 
dhSt
);

504 
	`tSg
(&
buf
, "MtoHUST", "DaFe", 
daFe
);

505 i(
bufTy
 != 0) {

506 
v
[10];

507 
	`rtf
(
v
, "%u.%u", 
vsi
[0], version[1]);

508 
	`tSg
(&
buf
, "MtoHUST", "Vsi", 
v
);

510 
	`tSg
(&
buf
, "MentoHUST", "Version", "3.95");

511 #ide
NO_NOTIFY


512 
	`tI
(&
buf
, "MtoHUST", "ShowNify", 
showNify
);

514 
	`tI
(&
buf
, "MtoHUST", "DmMode", 
dmMode
);

515 
	`tI
(&
buf
, "MtoHUST", "DhMode", 
dhMode
);

516 
	`tI
(&
buf
, "MtoHUST", "SMode", 
tMode
);

517 
	`tI
(&
buf
, "MtoHUST", "MaxFa", 
maxFa
);

518 
	`tI
(&
buf
, "MtoHUST", "RetWa", 
tWa
);

519 
	`tI
(&
buf
, "MtoHUST", "EchoIv", 
echoIv
);

520 
	`tI
(&
buf
, "MtoHUST", "Timeout", 
timeout
);

521 
	`tSg
(&
buf
, "MtoHUST", "PgHo", 
	`fmIP
(
pgHo
));

522 
	`tSg
(&
buf
, "MtoHUST", "DNS", 
	`fmIP
(
dns
));

523 
	`tSg
(&
buf
, "MtoHUST", "Geway", 
	`fmIP
(
geway
));

524 
	`tSg
(&
buf
, "MtoHUST", "Mask", 
	`fmIP
(
mask
));

525 
	`tSg
(&
buf
, "MtoHUST", "IP", 
	`fmIP
(

));

526 
	`tSg
(&
buf
, "MtoHUST", "Nic", 
nic
);

527 #ifde
NO_ENCODE_PASS


528 
	`tSg
(&
buf
, "MtoHUST", "Passwd", 
sswd
);

530 
ss
[
ACCOUNT_SIZE
*4/3+1];

531 
	`codePass
(
ss
+1, 
sswd
);

532 
ss
[0] = ' ';

533 
	`tSg
(&
buf
, "MtoHUST", "Passwd", 
ss
);

535 
	`tSg
(&
buf
, "MtoHUST", "Uame", 
urName
);

536 i(
	`veFe
(
buf
, 
CFG_FILE
) != 0)

537 
	`tf
(
	`_
("!! 保存认证参数到%s失败！\n"), 
CFG_FILE
);

539 
	`tf
(
	`_
("** 认证参数已成功保存到%s.\n"), 
CFG_FILE
);

540 
	`
(
buf
);

541 
	}
}

543 
	$checkRug
(
exFg
, 
dmMode
)

545 
ock
 

;

546 
lockfd
 = 
	`ݒ
 (
LOCK_FILE
, 
O_RDWR
|
O_CREAT
, 
LOCKMODE
);

547 i(
lockfd
 < 0) {

548 
	`
(
	`_
("!! 打开锁文件失败"));

549 
r_ex
;

551 

.
l_t
 = 0;

552 

.
l_wh
 = 
SEEK_SET
;

553 

.
l_n
 = 0;

554 

.
l_ty
 = 
F_WRLCK
;

555 i(
	`f
(
lockfd
, 
F_GETLK
, &

) < 0) {

556 
	`
(
	`_
("!! 获取文件锁失败"));

557 
r_ex
;

559 i(
exFg
) {

560 i(

.
l_ty
 !
F_UNLCK
) {

561 
	`tf
(
	`_
(">> 已发送退出信号给MtoHUST进程(PID=%d).\n"), 

.
l_pid
);

562 i(
	`kl
(

.
l_pid
, 
SIGINT
) == -1)

563 
	`
(
	`_
("!! 结束进程失败"));

566 
	`tf
(
	`_
("!! 没有MentoHUST正在运行！\n"));

567 i(
exFg
 == 1)

568 
	`ex
(
EXIT_SUCCESS
);

570 i(

.
l_ty
 !
F_UNLCK
) {

571 
	`tf
(
	`_
("!! MtoHUST已经运行(PID=%d)!\n"), 

.
l_pid
);

572 
	`ex
(
EXIT_FAILURE
);

574 i(
dmMode
) {

575 
	`tf
(
	`_
(">> 进入后台运行模式，使用参数-k可退出认证。\n"));

576 i(
	`dm
(0, (
dmMode
+1)%2))

577 
	`
(
	`_
("!! 后台运行失败"));

578 i(
dmMode
 == 3) {

579 
	`eݒ
(
LOG_FILE
, "w", 
dout
);

580 
	`tvbuf
(
dout
, (*)
NULL
, 
_IOLBF
, 
BUFSIZ
);

581 
	`eݒ
(
LOG_FILE
, "a", 
dr
);

584 

.
l_ty
 = 
F_WRLCK
;

585 

.
l_pid
 = 
	`gpid
();

586 i(
	`f
(
lockfd
, 
F_SETLKW
, &

) < 0) {

587 
	`
(
	`_
("!! 加锁失败"));

588 
r_ex
;

592 
r_ex
:

593 #ide
NO_NOTIFY


594 i(
showNify
 && 
	`show_nify
(
	`_
("MentoHUST - 错误提示"),

595 
	`_
("操作锁文件失败，请检查是否为ro权限！"), 1000*
showNify
) < 0)

596 
showNify
 = 0;

598 
	`ex
(
EXIT_FAILURE
);

599 
	}
}

	@myconfig.h

8 #ide
HUSTMOON_MYCONFIG_H


9 
	#HUSTMOON_MYCONFIG_H


	)

11 
Cfig
(
gc
, **
gv
);

	@myfunc.c

9 #ifde
HAVE_CONFIG_H


10 
	~"cfig.h
"

12 
	#HAVE_ICONV_H


	)

15 
	~"myfunc.h
"

16 
	~"i18n.h
"

17 
	~"md5.h
"

18 
	~"mycheck.h
"

19 
	~<dio.h
>

20 
	~<rg.h
>

21 
	~<dlib.h
>

22 
	~<t/.h
>

23 
	~<unid.h
>

24 
	~<sys/sock.h
>

25 
	~<sys/iol.h
>

26 
	~<t/if.h
>

27 
	~</.h
>

28 #ide
SIOCGIFHWADDR


29 
	~<t/if_dl.h
>

30 
	~<iddrs.h
>

32 
	~<sys/pl.h
>

34 #ifde
HAVE_ICONV_H


35 
	~<icv.h
>

38 cڡ 
u_ch
 
	gSTANDARD_ADDR
[] = {0x01,0x80,0xC2,0x00,0x00,0x03};

39 cڡ 
u_ch
 
	gRUIJIE_ADDR
[] = {0x01,0xD0,0xF8,0x00,0x00,0x03};

40 cڡ *
	gDATAFILE
 = "/etc/mentohust/";

42 
	gdaOfft
;

43 
u_t32_t
 
	gechoKey
 = 0, 
	gechoNo
 = 0;

44 
u_ch
 *
	gflBuf
 = 
NULL
;

45 
	gflSize
 = 0;

46 
	gbufTy
 = 0;

47 
u_ch
 
	gvsi
[2];

48 #ide
NO_ARP


49 
u_t32_t
 
	gr
 = 0;

50 
u_ch
 
	ggeMAC
[6];

53 
sswd
[];

54 
nic
[];

55 
daFe
[];

56 
u_t32_t
 

, 
mask
, 
geway
, 
dns
, 
pgHo
;

57 
u_ch
 
lolMAC
[], 
deMAC
[];

58 
tMode
, 
dhMode
;

60 
checkFe
();

61 
gVsi
();

62 
gAddss
();

63 
u_ch
 
code
(u_ch 
ba
);

64 
checkSum
(
u_ch
 *
buf
);

65 
tPrݔty
(
u_ch
 
ty
, cڡ u_ch *
vue
, 
ngth
);

66 
adPack
(
ty
);

67 
Check
(cڡ 
u_ch
 *
md5Sd
);

69 *
	$gbk2utf
(*
c
, 
size_t
 

) {

70 #ifde 
HAVE_ICONV_H


73 
size_t
 
dn
 = 

 * 3 / 2 + 1;

74 
size_t
 

 = 
dn
;

75 *
d
, *
pd
;

76 
s
;

77 
icv_t
 
cd
 = 
	`icv_ݒ
("utf-8", "gbk");

78 i(
cd
 =(
icv_t
)-1)

79  
NULL
;

80 
d
 = (*)
	`mloc
(
dn
);

81 
pd
 = 
d
;

82 
s
 = 
	`icv
(
cd
, &
c
, &

, &
pd
, &

);

83 
	`icv_o
(
cd
);

84 i(
s
 == -1) {

85 
	`
(
d
);

86  
NULL
;

88 
d
[
dn
-

] = '\0';

90 *
d
 = (*)
	`mloc
(

+1);

91 
	`memy
(
d
, 
c
, 

);

92 
d
[

] = '\0';

94  
d
;

95 
	}
}

97 *
	$fmIP
(
u_t32_t
 

)

99 
tmp
[16];

100 
u_ch
 *
p
 = (u_ch *)(&

);

101 
	`rtf
(
tmp
, "%d.%d.%d.%d", 
p
[0],[1],[2],[3]);

102  
tmp
;

103 
	}
}

105 *
	$fmHex
(cڡ *
buf
, 
ngth
)

107 
hex
[385];

108 
u_ch
 *
p
 = (u_ch *)
buf
;

109 
i
;

110 i(
ngth
 > 128)

111 
ngth
 = 128;

112 
i
=0; i<
ngth
; i++)

113 
	`rtf
(
hex
+3*
i
,"%02x:", 
p
[i]);

114 
hex
[3*
ngth
-1] = '\0';

115  
hex
;

116 
	}
}

118 
	$checkFe
() {

119 
u_ch
 
Buf
[16], *
buf
=Buf;

120 
FILE
 *

 = 
NULL
;

121 i((

=
	`fݒ
(
daFe
, "rb")=
NULL
)

122 
feE
;

123 i(
	`d
(
buf
, 16, 1, 

)<1 || 
	`memcmp
(buf, "HUST", 4)!=0) {

124 
	`fo
(

);

125 
feE
;

127 
daOfft
 = ()
	`LTOBL
(*(
u_t32_t
 *)
buf
 ^ *(u_int32_t *)(buf + 8)) + 16;

128 
	`fek
(

, 0, 
SEEK_END
);

129 
flSize
 = 
	`l
(

);

130 
	`fo
(

);

131 i(
daOfft
 < 16)

132 
feE
;

133 
flSize
 = (flSiz- 
daOfft
) / 2 + 0x17;

134 i(
flSize
<0x80 || fillSize>0x397)

135 
feE
;

138 
feE
:

139 i(
daFe
[
	`
(dataFile)-1] != '/')

140 
	`tf
(
	`_
("!! 所选文件%s无效，改用内置数据认证。\n"), 
daFe
);

142 
	}
}

144 
	$tSuCfig
(cڡ *
SuCfig
) {

145 
dbuf
[2048], *
xt
;

146 i(
	`decodeCfig
(
SuCfig
, (
BYTE
 *)
dbuf
, (dbuf))) {

147 
	`tf
(
	`_
("!! 指定的SuConfig.dat文件无效。\n"));

148 } i((
xt
=
	`gbk2utf
(
dbuf
, 
	`
(dbuf))!
NULL
) {

149 
	`tf
("%s\n", 
xt
);

150 
	`
(
xt
);

152 
	}
}

154 
	$gVsi
() {

155 
fe
[0x100], *
p
;

156 
DWORD
 
v
;

157 
	`ry
(
fe
, 
daFe
);

158 i((
p
=
	`chr
(
fe
, '/')+1) == (*)1)

159 
p
 = 
fe
;

160 
	`ry
(
p
, "8021x.exe");

161 i((
v
=
	`gV
(
fe
)=(
DWORD
)-1)

163 
p
 = (*)&
v
;

164 
vsi
[0] = 
p
[2];

165 
vsi
[1] = 
p
[0];

166 
bufTy
 = 1;

168 
	}
}

170 
	$wBufr
()

172 i(
daFe
[0] == '\0')

173 
	`ry
(
daFe
, 
DATAFILE
);

174 
	`gVsi
();

175 i(
	`checkFe
() == 0)

176 
bufTy
 += 2;

177 
flSize
 = (
bufTy
==0 ? 0x80 : 0x1d7);

178 
flBuf
 = (
u_ch
 *)
	`mloc
(
flSize
);

179 
	}
}

181 
	$gAddss
()

183 
ieq
 
i
;

184 #ide
SIOCGIFHWADDR


185 
iddrs
 *
ip
, *
p
 = 
NULL
;

186 
sockaddr_dl
 *
sdl
;

188 
sock
 = 
	`sock
(
AF_INET
, 
SOCK_DGRAM
, 0);

189 i(
sock
 < 0)

191 
	`tf
(
	`_
("!! 创建套接字失败!\n"));

194 
	`ry
(
i
.
i_me
, 
nic
);

196 #ifde
SIOCGIFHWADDR


197 i(
	`iol
(
sock
, 
SIOCGIFHWADDR
, &
i
) < 0)

198 
gMACE
;

199 
	`memy
(
lolMAC
, 
i
.
i_hwaddr
.
_da
, 6);

201 i(
	`giddrs
(&
ip
) == 0)

203 
p
=
ip
;;->
i_xt
)

205 i(
p
->
i_me
 && 
	`rcmp
->i_me, 
nic
)==0)

207 
sdl
 = (
sockaddr_dl
 *)
p
->
i_addr
;

208 
	`memy
(
lolMAC
, 
sdl
->
sdl_da
 + sdl->
sdl_ƒ
, 6);

212 
	`iddrs
(
ip
);

214 i(
p
 =
NULL
)

215 
gMACE
;

218 i(
tMode
 == 0)

219 
	`memy
(
deMAC
, 
STANDARD_ADDR
, 6);

220 i(
tMode
 == 1)

221 
	`memy
(
deMAC
, 
RUIJIE_ADDR
, 6);

223 #ide
NO_ARP


224 
geMAC
[0] = 0xFE;

225 i(
	`iol
(
sock
, 
SIOCGIFADDR
, &
i
) < 0)

226 
	`tf
(
	`_
("!! 在网卡%s上获取IP失败!\n"), 
nic
);

228 
r
 = ((
sockaddr_
 *)&
i
.
i_addr
)->
s_addr
.
s_addr
;

229 i(
geway
!=0 && (
tMode
%3!=2 || ((
u_ch
 *)&gateway)[3]!=0x02))

230 
geMAC
[0] = 0xFF;

232 i(
dhMode
!=0 || 

==-1)

233 

 = 
r
;

235 i(
dhMode
!=0 || 

==-1) {

236 i(
	`iol
(
sock
, 
SIOCGIFADDR
, &
i
) < 0)

237 
	`tf
(
	`_
("!! 在网卡%s上获取IP失败!\n"), 
nic
);

239 

 = ((
sockaddr_
 *)&
i
.
i_addr
)->
s_addr
.
s_addr
;

243 i(
dhMode
!=0 || 
mask
==-1) {

244 i(
	`iol
(
sock
, 
SIOCGIFNETMASK
, &
i
) < 0)

245 
	`tf
(
	`_
("!! 在网卡%s上获取子网掩码失败!\n"), 
nic
);

247 
mask
 = ((
sockaddr_
 *)&
i
.
i_addr
)->
s_addr
.
s_addr
;

249 
	`o
(
sock
);

251 
	`tf
(
	`_
("** 本机MAC:\t%s\n"), 
	`fmHex
(
lolMAC
, 6));

252 
	`tf
(
	`_
("** 使用IP:\t%s\n"), 
	`fmIP
(

));

253 
	`tf
(
	`_
("** 子网掩码:\t%s\n"), 
	`fmIP
(
mask
));

256 
gMACE
:

257 
	`o
(
sock
);

258 
	`tf
(
	`_
("!! 在网卡%s上获取MAC失败!\n"), 
nic
);

260 
	}
}

262 
u_ch
 
	$code
(
u_ch
 
ba
)

264 
u_ch
 
su
 = 0;

265 
i
;

266 
i
=0; i<8; i++)

268 
su
 <<= 1;

269 
su
 |
ba
&0x01;

270 
ba
 >>= 1;

272  ~
su
;

273 
	}
}

275 
	$checkSum
(
u_ch
 *
buf
)

277 
u_ch
 
b
[] =

312 
u_ch
 *
checkSum
 = 
buf
 + 0x15;

313 
i
, 
dex
;

314 
i
=0; i<0x15; i++)

316 
dex
 = 
checkSum
[0] ^ 
buf
[
i
];

317 
checkSum
[0] = checkSum[1] ^ 
b
[
dex
*2+1];

318 
checkSum
[1] = 
b
[
dex
*2];

320 
i
=0; i<0x17; i++)

321 
buf
[
i
] = 
	`code
(buf[i]);

322 
	}
}

324 
	$flHd
()

326 i(
	`gAddss
() == -1)

328 
	`memt
(
flBuf
, 0, 
flSize
);

329 
flBuf
[0x02] = 0x13;

330 
flBuf
[0x03] = 0x11;

331 i(
dhMode
 != 0)

332 
flBuf
[0x04] = 0x01;

333 
	`memy
(
flBuf
+0x05, &

, 4);

334 
	`memy
(
flBuf
+0x09, &
mask
, 4);

335 
	`memy
(
flBuf
+0x0D, &
geway
, 4);

336 
	`memy
(
flBuf
+0x11, &
dns
, 4);

337 
	`checkSum
(
flBuf
);

339 
	}
}

341 
	$tPrݔty
(
u_ch
 
ty
, cڡ u_ch *
vue
, 
ngth
)

343 
u_ch
 *
p
 = 
flBuf
+0x46, *
d
 = flBuf+
flSize
-
ngth
-8;

344 
p
 < 
d
)

346 i(*
p
 == 0x1a)

347 
p
 += 2;

348 i(
p
[4] =
ty
)

350 
	`memy
(
p
+4+p[5]-
ngth
, 
vue
,ength);

353 
p
 +=[5] + 4;

356 
	}
}

358 
	$adPack
(
ty
)

360 
u_ch
 
dh
[] = {0x00};

361 
FILE
 *

 = 
	`fݒ
(
daFe
, "rb");

362 i(

 =
NULL
)

363 
feE
;

364 
ty
 %= 2;

365 
	`fek
(

, 
daOfft
+(
flSize
-0x17)*
ty
, 
SEEK_SET
);

366 i(
	`d
(
flBuf
+0x17, 
flSize
-0x17, 1, 

) < 1)

368 
	`fo
(

);

369 
feE
;

371 
	`fo
(

);

372 i(
dhMode
 == 1)

373 
dh
[0] = 0x01;

374 
	`tPrݔty
(0x18, 
dh
, 1);

375 
	`tPrݔty
(0x2D, 
lolMAC
, 6);

376 i(
bufTy
 == 3)

377 
	`memy
(
flBuf
+0x3b, 
vsi
, 2);

380 
feE
:

381 
	`tf
(
	`_
("!! 所选文件%s无效，改用内置数据认证。\n"), 
daFe
);

382 
bufTy
 -= 2;

383 i(
bufTy
==1 && 
flSize
<0x1d7) {

384 
	`
(
flBuf
);

385 
flSize
 = 0x1d7;

386 
flBuf
 = (
u_ch
 *)
	`mloc
(
flSize
);

389 
	}
}

391 
	$flSPack
()

393 i(
bufTy
 <= 1) {

394 cڡ 
u_ch
 
ck0
[] = {

402 cڡ 
u_ch
 
ck1
[] = {

432 
u_ch
 
dh
[] = {0x00};

433 i(
dhMode
 == 1)

434 
dh
[0] = 0x01;

435 i(
bufTy
 == 1) {

436 
	`memy
(
flBuf
+0x17, 
ck1
, (packet1));

437 
	`memy
(
flBuf
+0x3b, 
vsi
, 2);

439 
	`memy
(
flBuf
+0x17, 
ck0
, (packet0));

440 
	`tPrݔty
(0x18, 
dh
, 1);

441 
	`tPrݔty
(0x2D, 
lolMAC
, 6);

443 i(
	`adPack
(0) == -1)

444 
	`flSPack
();

445 
	}
}

447 
	$flMd5Pack
(cڡ 
u_ch
 *
md5Sd
)

449 i(
bufTy
 <= 1) {

451 
	`flSPack
();

452 i(
bufTy
 == 1)

453 
	`Check
(
md5Sd
);

455 i(
	`adPack
(1) == -1)

456 
	`flMd5Pack
(
md5Sd
);

458 
	`Check
(
md5Sd
);

460 
echoNo
 = 0x0000102B;

461 
	}
}

463 
	$Check
(cڡ 
u_ch
 *
md5Sd
)

465 
f_r
[129];

466 
vue
;

467 
	`tf
(
	`_
("** 客户端版本:\t%d.%d\n"), 
flBuf
[0x3B], fillBuf[0x3C]);

468 
	`tf
(
	`_
("** MD5种子:\t%s\n"), 
	`fmHex
(
md5Sd
, 16));

469 
vue
 = 
	`check_
(
daFe
);

470 i(
vue
 == -1) {

471 
	`tf
(
	`_
("!! 缺少8021x.exe信息，客户端校验无法继续！\n"));

474 
	`V2_check
(
md5Sd
, 
f_r
);

475 
	`tf
(
	`_
("** V2校验值:\t%s\n"), 
f_r
);

476 
	`tPrݔty
(0x17, (
u_ch
 *)
f_r
, 32);

477 
	`check_
();

479 
	}
}

481 
	$flEchoPack
(
u_ch
 *
echoBuf
)

483 
i
;

484 
u_t32_t
 
dd1
=
	`htl
(
echoKey
 + 
echoNo
), 
dd2
=htonl(echoNo);

485 
u_ch
 *
bt1
=(u_ch *)&
dd1
, *
bt2
=(u_ch *)&
dd2
;

486 
echoNo
++;

487 
i
=0; i<4; i++)

489 
echoBuf
[0x18+
i
] = 
	`code
(
bt1
[i]);

490 
echoBuf
[0x22+
i
] = 
	`code
(
bt2
[i]);

492 
	}
}

494 
	$gEchoKey
(cڡ 
u_ch
 *
pBuf
)

496 
i
, 
offt
 = 0x1c+
pBuf
[0x1b]+0x69+24;

497 
u_ch
 *
ba
 = (u_ch *)(&
echoKey
);

498 
i
=0; i<4; i++)

499 
ba
[
i
] = 
	`code
(
pBuf
[
offt
+i]);

500 
echoKey
 = 
	`ohl
(echoKey);

501 
	}
}

503 
u_ch
 *
	$checkPass
(
u_ch
 
id
, cڡ u_ch *
md5Sd
, 
edL
)

505 
u_ch
 
md5Src
[80];

506 
md5L
 = 
	`
(
sswd
);

507 
md5Src
[0] = 
id
;

508 
	`memy
(
md5Src
+1, 
sswd
, 
md5L
);

509 
md5L
++;

510 i(
tMode
 % 3 == 2)

512 
	`memy
(
md5Src
+
md5L
, "xxghlmxhzb", 10);

513 
md5L
 += 10;

515 
	`memy
(
md5Src
+
md5L
, 
md5Sd
, 
edL
);

516 
md5L
 +
edL
;

517  
	`CompuHash
(
md5Src
, 
md5L
);

518 
	}
}

520 
	$flCtAddr
(
u_ch
 *
buf
)

522 
	`memy
(
buf
+0x18, &

, 4);

523 
	`memy
(
buf
+0x1C, &
mask
, 4);

524 
	`memy
(
buf
+0x20, &
geway
, 4);

525 
	`memt
(
buf
+0x24, 0, 4);

526 
	}
}

528 
	$isOƚe
()

530 
u_ch
 
echoPack
[] =

537 
sock
=-1, 
V
, 
t
;

538 
plfd
 
pfd
;

539 
sockaddr_
 
de
;

540 i(
pgHo
 == 0)

542 
	`memt
(&
de
, 0, (dest));

543 
de
.
s_my
 = 
AF_INET
;

544 
de
.
s_addr
.
s_addr
 = 
pgHo
;

545 i((
sock
=
	`sock
(
AF_INET
, 
SOCK_RAW
, 
IPPROTO_ICMP
)) < 0)

546 
pgE
;

547 
pfd
.
fd
 = 
sock
;

548 
pfd
.
evts
 = 
POLLIN
;

549 
t
=1;<=3;++) {

550 i(
	`ndto
(
sock
, 
echoPack
, (echoPacket), 0,

551 (
sockaddr
 *)&
de
, (dest)) < 0)

552 
pgE
;

553 
V
 = 
	`pl
(&
pfd
, 1, 
t
*1000);

554 i(
V
 == -1)

555 
pgE
;

556 i(
V
 > 0) {

557 
	`o
(
sock
);

561 
	`o
(
sock
);

564 
pgE
:

565 
	`
(
	`_
("!! Ping主机出错，关闭该功能"));

566 i(
sock
 != -1)

567 
	`o
(
sock
);

568 
pgHo
 = 0;

570 
	}
}

	@myfunc.h

8 #ide
HUSTMOON_MYFUNC_H


9 
	#HUSTMOON_MYFUNC_H


	)

11 
	~<sys/tys.h
>

13 *
gbk2utf
(*
c
, 
size_t
 

);

14 *
fmIP
(
u_t32_t
 

);

15 *
fmHex
(cڡ *
buf
, 
ngth
);

16 
tSuCfig
(cڡ *
SuCfig
);

17 
wBufr
();

18 
flHd
();

19 
flSPack
();

20 
flMd5Pack
(cڡ 
u_ch
 *
md5Sd
);

21 
flEchoPack
(
u_ch
 *
buf
);

22 
gEchoKey
(cڡ 
u_ch
 *
pBuf
);

23 
u_ch
 *
checkPass
(u_ch 
id
, cڡ u_ch *
md5Sd
, 
edL
);

24 
flCtAddr
(
u_ch
 *
buf
);

25 
isOƚe
();

	@myini.c

10 
	~"myi.h
"

11 
	~<dio.h
>

12 
	~<rg.h
>

14 
	#NOT_COMMENT
(
c
(c!=';' && c!='#'

	)

16 #ide
icmp


17 
	#icmp
 
cmp


	)

20 
gLe
(cڡ *
buf
, 
S
, *
leS
, *
leEnd
);

21 
fdKey
(cڡ *
buf
, cڡ *
i
, cڡ *
key
,

22 *
iS
, *
vueS
, *
vueSize
);

23 
gSei
(cڡ *
buf
, 
S
);

25 
	$ldFe
(**
buf
, cڡ *
feName
)

27 
FILE
 *

 = 
NULL
;

28 
size
 = 0;

29 i((

=
	`fݒ
(
feName
, "rb")=
NULL
)

31 
	`fek
(

, 0, 
SEEK_END
);

32 
size
 = 
	`l
(

);

33 
	`wd
(

);

34 *
buf
 = (*)
	`mloc
(
size
+1);

35 (*
buf
)[
size
] = '\0';

36 i(
	`d
(*
buf
, 
size
, 1, 

) < 1) {

37 
	`
(*
buf
);

38 
size
 = -1;

40 
	`fo
(

);

41  
size
;

42 
	}
}

44 
	$gLe
(cڡ *
buf
, 
S
, *
leS
, *
leEnd
)

46 
t
, 
d
;

47 
t
=
S
; 
buf
[start]==' ' || buf[start]=='\t' || buf[start]=='\r' || buf[start]=='\n'; start++);

48 
d
=
t
; 
buf
[end]!='\r' && buf[end]!='\n' && buf[end]!='\0';nd++);

49 *
leS
 = 
t
;

50 *
leEnd
 = 
d
;

51 
	}
}

53 
	$fdKey
(cڡ *
buf
, cڡ *
i
, cڡ *
key
,

54 *
iS
, *
vueS
, *
vueSize
)

56 
leS
, 
leEnd
, 
i
;

57 *
iS
=-1, 
leEnd
=0; 
buf
[lineEnd]!='\0'; )

59 
	`gLe
(
buf
, 
leEnd
, &
leS
, &lineEnd);

60 i(
buf
[
leS
] == '[')

62 
i
=++
leS
; i<
leEnd
 && 
buf
[i]!=']'; i++);

63 i(
i
<
leEnd
 && 
	`icmp
(
buf
+
leS
, 
i
, i-lineStart)==0)

65 *
iS
 = 
leS
-1;

66 i(
key
 =
NULL
)

69 i(*
iS
 != -1)

72 i(*
iS
!=-1 && 
	`NOT_COMMENT
(
buf
[
leS
]))

74 
i
=
leS
+1; i<
leEnd
 && 
buf
[i]!='='; i++);

75 i(
i
<
leEnd
 && 
	`icmp
(
buf
+
leS
, 
key
, i-lineStart)==0)

77 *
vueS
 = 
i
 + 1;

78 *
vueSize
 = 
leEnd
 - *
vueS
;

84 
	}
}

86 
	$gSg
(cڡ *
buf
, cڡ *
i
, cڡ *
key
,

87 cڡ *
deuVue
, *
vue
, 
size
)

89 
iS
, 
vueS
;

90 
vueSize
;

92 i(
	`fdKey
(
buf
, 
i
, 
key
, &
iS
, &
vueS
, &
vueSize
)!=0 || valueSize==0)

94 
	`y
(
vue
, 
deuVue
, 
size
);

97 i(
size
-1 < 
vueSize
)

98 
vueSize
 = 
size
 - 1;

99 
	`memt
(
vue
, 0, 
size
);

100 
	`y
(
vue
, 
buf
+
vueS
, 
vueSize
);

102 
	}
}

104 
	$gI
(cڡ *
buf
, cڡ *
i
, cڡ *
key
, 
deuVue
)

106 
vue
[21] = {0};

107 
	`gSg
(
buf
, 
i
, 
key
, "", 
vue
, (value));

108 i(
vue
[0] == '\0')

109  
deuVue
;

110  
	`oi
(
vue
);

111 
	}
}

113 
	$tSg
(**
buf
, cڡ *
i
, cڡ *
key
, cڡ *
vue
)

115 
iS
, 
vueS
;

116 
vueSize
;

117 *
wBuf
 = 
NULL
;

119 i(
	`fdKey
(*
buf
, 
i
, 
key
, &
iS
, &
vueS
, &
vueSize
) == 0)

121 i(
vue
 =
NULL
)

122 
	`memmove
(*
buf
+
vueS
-
	`
(
key
)-1, *buf+vueS+
vueSize
,

123 
	`
(*
buf
)+1-
vueS
-
vueSize
);

126 
wBuf
 = (*)
	`mloc
(
	`
(*
buf
)-
vueSize
+(
vue
)+1);

127 
	`memy
(
wBuf
, *
buf
, 
vueS
);

128 
	`ry
(
wBuf
+
vueS
, 
vue
);

129 
	`ry
(
wBuf
+
vueS
+
	`
(
vue
), *
buf
+vueS+
vueSize
);

130 
	`
(*
buf
);

131 *
buf
 = 
wBuf
;

134 i(
iS
 != -1)

136 i(
key
 =
NULL
)

138 
vueS
 = 
	`gSei
(*
buf
, 
iS
+3);

139 i(
vueS
 <
iS
)

140 (*
buf
)[
iS
] = '\0';

142 
	`memmove
(*
buf
+
iS
, *buf+
vueS
, 
	`
(*buf)+1-valueStart);

144 i(
vue
 !
NULL
)

146 
wBuf
 = (*)
	`mloc
(
	`
(*
buf
)+(
key
)+(
vue
)+4);

147 
vueSize
 = 
iS
+
	`
(
i
)+2;

148 
	`memy
(
wBuf
, *
buf
, 
vueSize
);

149 
	`rtf
(
wBuf
+
vueSize
, "\n%s=%s", 
key
, 
vue
);

150 
	`ry
(
wBuf
+
	`
ewBuf), *
buf
+
vueSize
);

151 
	`
(*
buf
);

152 *
buf
 = 
wBuf
;

157 i(
key
!=
NULL
 && 
vue
!=NULL)

159 
wBuf
 = (*)
	`mloc
(
	`
(*
buf
)+(
i
)+(
key
)+(
vue
)+8);

160 
	`ry
(
wBuf
, *
buf
);

161 
	`rtf
(
wBuf
+
	`
ewBuf), "\n[%s]\n%s=%s", 
i
, 
key
, 
vue
);

162 
	`
(*
buf
);

163 *
buf
 = 
wBuf
;

166 
	}
}

168 
	$gSei
(cڡ *
buf
, 
S
)

170 
leS
, 
leEnd
, 
i
;

171 
leEnd
=
S
; 
buf
[lineEnd]!='\0'; )

173 
	`gLe
(
buf
, 
leEnd
, &
leS
, &lineEnd);

174 i(
buf
[
leS
] == '[')

176 
i
=
leS
+1; i<
leEnd
 && 
buf
[i]!=']'; i++);

177 i(
i
 < 
leEnd
)

178  
leS
;

182 
	}
}

184 
	$tI
(**
buf
, cڡ *
i
, cڡ *
key
, 
vue
)

186 
svue
[21];

187 
	`rtf
(
svue
, "%d", 
vue
);

188 
	`tSg
(
buf
, 
i
, 
key
, 
svue
);

189 
	}
}

191 
	$veFe
(cڡ *
buf
, cڡ *
feName
)

193 
FILE
 *

;

194 
su
;

196 i((

=
	`fݒ
(
feName
, "wb")=
NULL
)

198 
su
 = 
	`fwre
(
buf
, 
	`
(buf), 1, 

)<1 ? -1 : 0;

199 
	`fo
(

);

200  
su
;

201 
	}
}

	@myini.h

10 #ide
HUSTMOON_MYINI_H


11 
	#HUSTMOON_MYINI_H


	)

13 
	~<dlib.h
>

15 #ifde
__lulus


20 
ldFe
(**
buf
, cڡ *
feName
);

21 
gSg
(cڡ *
buf
, cڡ *
i
, cڡ *
key
,

22 cڡ *
deuVue
, *
vue
, 
size
);

23 
gI
(cڡ *
buf
, cڡ *
i
, cڡ *
key
, 
deuVue
);

24 
tSg
(**
buf
, cڡ *
i
, cڡ *
key
, cڡ *
vue
);

25 
tI
(**
buf
, cڡ *
i
, cڡ *
key
, 
vue
);

26 
veFe
(cڡ *
buf
, cڡ *
feName
);

28 #ifde
__lulus


	@mystate.c

10 
	~"mye.h
"

11 
	~"i18n.h
"

12 
	~"myfunc.h
"

13 
	~"dlfunc.h
"

14 
	~<rg.h
>

15 
	~<dlib.h
>

16 
	~<t/.h
>

17 
	~<sys/tys.h
>

18 
	~<sys/wa.h
>

19 
	~<unid.h
>

20 
	#MAX_SEND_COUNT
 3

	)

22 vީ
	ge
 = 
ID_DISCONNECT
;

23 cڡ 
u_ch
 *
	gpBuf
 = 
NULL
;

24 
u_ch
 
	gndPack
[0x3E8];

25 
	gndCou
 = 0;

27 cڡ 
u_ch
 
STANDARD_ADDR
[];

28 
urName
[];

29 
tMode
;

30 
dhMode
;

31 
u_ch
 
lolMAC
[], 
deMAC
[];

32 
timeout
;

33 
echoIv
;

34 
tWa
;

35 
dhSt
[];

36 
nic
[];

37 
pp_t
 *
hPp
;

38 
u_ch
 *
flBuf
;

39 
flSize
;

40 
u_t32_t
 
pgHo
;

41 
u_t32_t
 

;

42 #ide
NO_ARP


43 
u_t32_t
 
r
, 
geway
;

44 
u_ch
 
geMAC
[];

45 
ndAPack
();

48 
tTim
(
rv
);

49 
wIP
();

50 
flEthAddr
(
u_t32_t
 
oc
);

51 
ndSPack
();

52 
ndIdtyPack
();

53 
ndChngePack
();

54 
ndEchoPack
();

55 
ndLogoffPack
();

56 
waEchoPack
();

58 
	$tTim
(
rv
)

60 
imv
 
tim
;

61 
tim
.
_vue
.
tv_c
 = 
rv
;

62 
tim
.
_vue
.
tv_uc
 = 0;

63 
tim
.
_rv
.
tv_c
 = 
rv
;

64 
tim
.
_rv
.
tv_uc
 = 0;

65 
	`tim
(
ITIMER_REAL
, &
tim
, 
NULL
);

66 
	}
}

68 
	$swchS
(
ty
)

70 i(
e
 =
ty
)

71 
ndCou
++;

74 
e
 = 
ty
;

75 
ndCou
 = 0;

77 i(
ndCou
>=
MAX_SEND_COUNT
 && 
ty
!=
ID_ECHO
)

79 
ty
)

81 
ID_START
:

82 
	`tf
(
	`_
(">> 找不到服务器，重启认证!\n"));

84 
ID_IDENTITY
:

85 
	`tf
(
	`_
(">> 发送用户名超时，重启认证!\n"));

87 
ID_CHALLENGE
:

88 
	`tf
(
	`_
(">> 发送密码超时，重启认证!\n"));

90 
ID_WAITECHO
:

91 
	`tf
(
	`_
(">> 等候响应包超时，自行响应!\n"));

92  
	`swchS
(
ID_ECHO
);

94  
	`t
();

96 
ty
)

98 
ID_DHCP
:

99  
	`wIP
();

100 
ID_START
:

101  
	`ndSPack
();

102 
ID_IDENTITY
:

103  
	`ndIdtyPack
();

104 
ID_CHALLENGE
:

105  
	`ndChngePack
();

106 
ID_WAITECHO
:

107  
	`waEchoPack
();

108 
ID_ECHO
:

109 i(
pgHo
 && 
ndCou
*
echoIv
 > 60) {

110 i(
	`isOƚe
() == -1) {

111 
	`tf
(
	`_
(">> 认证掉线，开始重连!\n"));

112  
	`swchS
(
ID_START
);

114 
ndCou
 = 1;

116 #ide
NO_ARP


117 i(
geMAC
[0] != 0xFE)

118 
	`ndAPack
();

120  
	`ndEchoPack
();

121 
ID_DISCONNECT
:

122  
	`ndLogoffPack
();

125 
	}
}

127 
	$t
()

129 i(
tMode
 >= 3)

130 
tMode
 -= 3;

131 
e
 = 
ID_START
;

132 
ndCou
 = -1;

133 
	`tTim
(
tWa
);

135 
	}
}

137 
	$wIP
()

139 
pid_t
 
pid
;

140 
	`tTim
(0);

141 
	`tf
(
	`_
(">> 正在获取IP...\n"));

143 
pid
=
	`fk
();

144 
pid
)

147 
	`exep
(
dhSt
,dhSt,
nic
,"-v",
NULL
);

150 if(
pid
!=0)

152 
_v
;

153 
pid_t
 
chd_pid
;

154 
dh_t_v
;

155 
chd_pid
=
	`wa
(&
_v
);

156 i(!
	`WIFEXITED
(
_v
))

158 
	`tf
(
	`_
(">> 获取IP失败！\n"));

159 
	`ex
(
EXIT_FAILURE
);

161 
dh_t_v
=
	`WEXITSTATUS
(
_v
);

162 if(
dh_t_v
)

164 
	`tf
(
	`_
(">> 获取IP失败！\n"));

165 
	`ex
(
EXIT_FAILURE
);

168 
	`tf
(
	`_
(">> 操作结束。\n"));

169 
dhMode
 += 3;

170 i(
	`flHd
() == -1)

171 
	`ex
(
EXIT_FAILURE
);

172 i(
dhMode
 == 5)

173  
	`swchS
(
ID_ECHO
);

174  
	`swchS
(
ID_START
);

175 
	}
}

177 
	$flEthAddr
(
u_t32_t
 
oc
)

179 
	`memt
(
ndPack
, 0, 0x3E8);

180 
	`memy
(
ndPack
, 
deMAC
, 6);

181 
	`memy
(
ndPack
+0x06, 
lolMAC
, 6);

182 *(
u_t32_t
 *)(
ndPack
+0x0C
	`htl
(
oc
);

183 
	}
}

185 
	$ndSPack
()

187 i(

==0)

189 
	`tf
(
	`_
("IP地址错误，请重试！"));

190 
	`ex
(
EXIT_FAILURE
);

193 i(
tMode
%3 == 2)

195 i(
ndCou
 == 0)

197 
	`tf
(
	`_
(">> 寻找服务器...\n"));

198 
	`memy
(
ndPack
, 
STANDARD_ADDR
, 6);

199 
	`memy
(
ndPack
+0x06, 
lolMAC
, 6);

200 *(
u_t32_t
 *)(
ndPack
+0x0C
	`htl
(0x888E0101);

201 *(
u_t16_t
 *)(
ndPack
+0x10) = 0;

202 
	`memt
(
ndPack
+0x12, 0xa5, 42);

203 
	`tTim
(
timeout
);

205  
	`pp_ndck
(
hPp
, 
ndPack
, 60);

207 i(
ndCou
 == 0)

209 
	`tf
(
	`_
(">> 寻找服务器...\n"));

210 
	`flSPack
();

211 
	`flEthAddr
(0x888E0101);

212 
	`memy
(
ndPack
+0x12, 
flBuf
, 
flSize
);

213 
	`tTim
(
timeout
);

215  
	`pp_ndck
(
hPp
, 
ndPack
, 0x3E8);

216 
	}
}

218 
	$ndIdtyPack
()

220 
meL
 = 
	`
(
urName
);

221 i(
tMode
%3 == 2)

223 i(
ndCou
 == 0)

225 
	`tf
(
	`_
(">> 发送用户名...\n"));

226 *(
u_t16_t
 *)(
ndPack
+0x0E
	`hts
(0x0100);

227 *(
u_t16_t
 *)(
ndPack
+0x10*(u_t16_*)(ndPack+0x14
	`hts
(
meL
+30);

228 
ndPack
[0x12] = 0x02;

229 
ndPack
[0x16] = 0x01;

230 
ndPack
[0x17] = 0x01;

231 
	`flCtAddr
(
ndPack
);

232 
	`memy
(
ndPack
+0x28, "03.02.05", 8);

233 
	`memy
(
ndPack
+0x30, 
urName
, 
meL
);

234 
	`tTim
(
timeout
);

236 
ndPack
[0x13] = 
pBuf
[0x13];

237  
	`pp_ndck
(
hPp
, 
ndPack
, 
meL
+48);

239 i(
ndCou
 == 0)

241 
	`tf
(
	`_
(">> 发送用户名...\n"));

242 
	`flEthAddr
(0x888E0100);

243 
meL
 = 
	`
(
urName
);

244 *(
u_t16_t
 *)(
ndPack
+0x14*(u_t16_*)(ndPack+0x10
	`hts
(
meL
+5);

245 
ndPack
[0x12] = 0x02;

246 
ndPack
[0x13] = 
pBuf
[0x13];

247 
ndPack
[0x16] = 0x01;

248 
	`memy
(
ndPack
+0x17, 
urName
, 
meL
);

249 
	`memy
(
ndPack
+0x17+
meL
, 
flBuf
, 
flSize
);

250 
	`tTim
(
timeout
);

252  
	`pp_ndck
(
hPp
, 
ndPack
, 0x3E8);

253 
	}
}

255 
	$ndChngePack
()

257 
meL
 = 
	`
(
urName
);

258 i(
tMode
%3 == 2)

260 i(
ndCou
 == 0)

262 
	`tf
(
	`_
(">> 发送密码...\n"));

263 *(
u_t16_t
 *)(
ndPack
+0x0E
	`hts
(0x0100);

264 *(
u_t16_t
 *)(
ndPack
+0x10*(u_t16_*)(ndPack+0x14
	`hts
(
meL
+22);

265 
ndPack
[0x12] = 0x02;

266 
ndPack
[0x13] = 
pBuf
[0x13];

267 
ndPack
[0x16] = 0x04;

268 
ndPack
[0x17] = 16;

269 
	`memy
(
ndPack
+0x18, 
	`checkPass
(
pBuf
[0x13], capBuf+0x18, capBuf[0x17]), 16);

270 
	`memy
(
ndPack
+0x28, 
urName
, 
meL
);

271 
	`tTim
(
timeout
);

273  
	`pp_ndck
(
hPp
, 
ndPack
, 
meL
+40);

275 i(
ndCou
 == 0)

277 
	`tf
(
	`_
(">> 发送密码...\n"));

278 
	`flMd5Pack
(
pBuf
+0x18);

279 
	`flEthAddr
(0x888E0100);

280 *(
u_t16_t
 *)(
ndPack
+0x14*(u_t16_*)(ndPack+0x10
	`hts
(
meL
+22);

281 
ndPack
[0x12] = 0x02;

282 
ndPack
[0x13] = 
pBuf
[0x13];

283 
ndPack
[0x16] = 0x04;

284 
ndPack
[0x17] = 16;

285 
	`memy
(
ndPack
+0x18, 
	`checkPass
(
pBuf
[0x13], capBuf+0x18, capBuf[0x17]), 16);

286 
	`memy
(
ndPack
+0x28, 
urName
, 
meL
);

287 
	`memy
(
ndPack
+0x28+
meL
, 
flBuf
, 
flSize
);

288 
	`tTim
(
timeout
);

290  
	`pp_ndck
(
hPp
, 
ndPack
, 0x3E8);

291 
	}
}

293 
	$ndEchoPack
()

295 i(
tMode
%3 == 2)

297 *(
u_t16_t
 *)(
ndPack
+0x0E
	`hts
(0x0106);

298 *(
u_t16_t
 *)(
ndPack
+0x10) = 0;

299 
	`memt
(
ndPack
+0x12, 0xa5, 42);

300 
	`swchS
(
ID_WAITECHO
);

301  
	`pp_ndck
(
hPp
, 
ndPack
, 60);

303 i(
ndCou
 == 0)

305 
u_ch
 
echo
[] =

310 
	`tf
(
	`_
(">> 发送心跳包以保持在线...\n"));

311 
	`flEthAddr
(0x888E01BF);

312 
	`memy
(
ndPack
+0x10, 
echo
, (echo));

313 
	`tTim
(
echoIv
);

315 
	`flEchoPack
(
ndPack
);

316  
	`pp_ndck
(
hPp
, 
ndPack
, 0x2D);

317 
	}
}

319 
	$ndLogoffPack
()

321 
	`tTim
(0);

322 i(
tMode
%3 == 2)

324 *(
u_t16_t
 *)(
ndPack
+0x0E
	`hts
(0x0102);

325 *(
u_t16_t
 *)(
ndPack
+0x10) = 0;

326 
	`memt
(
ndPack
+0x12, 0xa5, 42);

327  
	`pp_ndck
(
hPp
, 
ndPack
, 60);

329 
	`flSPack
();

330 
	`flEthAddr
(0x888E0102);

331 
	`memy
(
ndPack
+0x12, 
flBuf
, 
flSize
);

332  
	`pp_ndck
(
hPp
, 
ndPack
, 0x3E8);

333 
	}
}

335 
	$waEchoPack
()

337 i(
ndCou
 == 0)

338 
	`tTim
(
echoIv
);

340 
	}
}

342 #ide
NO_ARP


343 
	$ndAPack
()

345 
u_ch
 
pPack
[0x3C] = {

349 i(
geMAC
[0] != 0xFF) {

350 
	`memy
(
pPack
, 
geMAC
, 6);

351 
	`memy
(
pPack
+0x06, 
lolMAC
, 6);

352 
pPack
[0x15]=0x02;

353 
	`memy
(
pPack
+0x16, 
lolMAC
, 6);

354 
	`memy
(
pPack
+0x1c, &
r
, 4);

355 
	`memy
(
pPack
+0x20, 
geMAC
, 6);

356 
	`memy
(
pPack
+0x26, &
geway
, 4);

357 
	`pp_ndck
(
hPp
, 
pPack
, 0x3C);

359 
	`memt
(
pPack
, 0xFF, 6);

360 
	`memy
(
pPack
+0x06, 
lolMAC
, 6);

361 
pPack
[0x15]=0x01;

362 
	`memy
(
pPack
+0x16, 
lolMAC
, 6);

363 
	`memy
(
pPack
+0x1c, &
r
, 4);

364 
	`memt
(
pPack
+0x20, 0, 6);

365 
	`memy
(
pPack
+0x26, &
geway
, 4);

366 
	`pp_ndck
(
hPp
, 
pPack
, 0x2A);

367 
	}
}

	@mystate.h

8 #ide
HUSTMOON_MYSTATE_H


9 
	#HUSTMOON_MYSTATE_H


	)

11 
	#ID_DISCONNECT
 0

	)

12 
	#ID_START
 1

	)

13 
	#ID_IDENTITY
 2

	)

14 
	#ID_CHALLENGE
 3

	)

15 
	#ID_ECHO
 4

	)

16 
	#ID_DHCP
 5

	)

17 
	#ID_WAITECHO
 6

	)

19 
swchS
(
ty
);

20 
t
();

	@types.h

1 #ide
TYPES_H


2 
	#TYPES_H


	)

3 *
	tPOINTER
;

4 
	tBYTE
;

5 
	tUCHAR
;

6 
	tWORD
;

7 
	tLONG
;

8 
	tDWORD
;

9 
	tUINT4
;

	@
1
.
0
17
153
dlfunc.c
dlfunc.h
i18n.h
md5.c
md5.h
mentohust.c
mycheck.c
mycheck.h
myconfig.c
myconfig.h
myfunc.c
myfunc.h
myini.c
myini.h
mystate.c
mystate.h
types.h
